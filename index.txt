782. Avoid "suspected robbery"

Small towns are distributed along the street (which can be understood as all on the number axis), with N banks (the location is represented by the coordinates of the number axis, and the amount represents the amount that can be robbed).

The two kidnappers tried to rob a bank each, and in order to get the police to travel more, they agreed to choose two banks not less than apart D.

Excuse me, what is the maximum total amount they can grab if they meet the agreement.

Input format
Input contains N + 1 lines.

The first line contains two integers N and D, indicating the number of banks and the agreed distance respectively.

Next N lines, each containing two integers A and B, indicating the coordinates and the amount respectively.

Output format
Output a number indicating the maximum amount that can be obtained.

Data scope
1 ≤ N ≤ 2 × 10^5
1 ≤ D, A, B ≤ 10^8

The data guarantee that at least two banks are present at a distance of not less than D.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

1454. Number of Subsets with Prime XOR Sum

You are given n distinct positive integers.

Count how many subsets of these integers have their XOR-sum equal to a prime number.

Since the answer can be very large, output it modulo 10^9 + 7.

Input

The first line contains an integer n.

The second line contains n distinct positive integers.

Output

Output a single integer — the number of subsets whose XOR-sum is prime, modulo 10^9 + 7.

Constraints

1 ≤ n ≤ 5000

1 ≤ each integer ≤ 5000

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

756. Serpentine Matrix

Enter two integers N and M, output an N × M matrix.
Fill the numbers from 1 to N × M into the matrix in a backward serpentine (spiral) order.

You can refer to the sample example for the specific filling pattern.

Input format

A single line containing two integers N and M.

Output format

Output an N × M matrix that meets the requirement.

The matrix has N rows, and each row contains M integers separated by spaces.

Data constraints

1 ≤ N, M ≤ 100

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXxxxxxxxxxxxxxxxxxx

Problem 1487: Coin Selection

Problem Statement:
You are given n1 + n2 types of coins. 
- The first n1 types are ordinary coins, which you can pick any number of times.
- The next n2 types are commemorative coins, of which you can pick at most 1 coin of each type. 
Each coin has a positive integer face value.  

Your task is to find the number of ways to form a total sum of exactly m using these coins. 
Output the result modulo 10^9 + 7.

Input Format:
- First line: three integers n1, n2, m 
  (number of ordinary coins, number of commemorative coins, target sum)
- Second line: n1 integers a[1..n1], the face values of ordinary coins (strictly increasing)
- Third line: n2 integers b[1..n2], the face values of commemorative coins (strictly increasing)

Output Format:
- One integer x: the total number of ways to form sum m modulo 10^9 + 7.

Constraints:
- For 30% of data: 1 ≤ n1+n2 ≤ 10, 1 ≤ m ≤ 100, 1 ≤ a[i], b[i] ≤ 100
- For 100% of data: 1 ≤ n1+n2 ≤ 100, 1 ≤ m ≤ 100000, 1 ≤ a[i], b[i] ≤ 100000

Sample Input:
3 1 5
1 2 3
1

Sample Output:
9

Explanation:
(x) denotes ordinary coins, [x] denotes commemorative coins. All ways to make sum 5:
(1)(1)(1)(1)(1)
(1)(1)(1)(2)
(1)(1)(3)
(1)(2)(2)
(2)(3)
(1)(1)(1)(1)[1]
(1)(1)(1)(2)

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

730. Robot Jumping Problem

A robot is playing an old DOS-based game.

In the game, there are N+1 buildings indexed from 0 to N, arranged from left to right.

The height of building 0 is 0 units.

The height of building i (where i ≥ 1) is given by H(i) units.

Initially, the robot starts at building 0.

At each step, the robot jumps to the next building (i.e., from building k to building k+1).

Energy Requirement:

Assume the robot is at building k and its current energy is E.

When it jumps to building k+1, if the height of building k+1 (H(k+1)) is greater than E, the robot loses energy equal to the difference H(k+1) - E.

If the height of building k+1 is less than or equal to E, the robot gains energy equal to E - H(k+1).

Goal:

The robot’s goal is to reach building N. The robot’s energy should never go below 0 during the journey.

Problem:

Given the heights of the buildings, find the minimum initial energy E the robot must have in order to reach building N without ever running out of energy.

Input Format:

The first line contains an integer N.

The second line contains N integers, representing the heights of the buildings (from building 1 to building N).

Output Format:

Output the minimum initial energy E (rounded up to the nearest integer) required for the robot to reach building N.

Constraints:

1 ≤ N ≤ 100,000

1 ≤ H(i) ≤ 1,000,000,000

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem Description:

In a small town, there are n banks, and each bank is located along a straight line (on the number axis). Each bank has a position and an amount of money that can be stolen from them.

Two robbers are trying to rob two different banks. However, to make the police chase them more effectively, they agree that the distance between the two banks they rob must be at least d.

Your task is to determine the maximum amount of money they can steal while following the constraint of the minimum distance between the two robbed banks.

Input Format:

The first line contains two integers n and d, representing the number of banks and the minimum distance between the two banks that the robbers can rob.

The next n lines each contain two integers:

a: The position of a bank on the number line.

b: The amount of money available at that bank, respectively.

Output Format:

Output a single integer, which is the maximum total amount of money the two robbers can steal.

Constraints:

1 ≤ n ≤ 200,000

1 ≤ d, a, b ≤ 100,000,000

Note: It is guaranteed that there are at least two banks whose distance is not less than d.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

NAJ0001 - Divisible Number Sum

Hazzat is a new guy in computer science, now in his 3rd semester. He recently completed a data structures course but keeps encountering problems he can't solve with the structures he knows. He wants to establish a new data structure but keeps failing. Help Hazzat by solving the following problem.

You are given an array A of N integers. You need to answer M queries.

Each query is of the form: V x y

For each query, consider the subarray A[x..y] (1-based indices). Let S be the subset of elements in this range that are fully divisible by V; i.e., include A[i] in S if x ≤ i ≤ y and A[i] % V == 0. Output the sum of all elements in S.

Input
- The first line contains an integer T (1 ≤ T ≤ 5) — the number of test cases.
For each test case:
- A line with two integers N and M (1 ≤ N ≤ 10^5, 1 ≤ M ≤ 2×10^5).
- A line with N integers: A[1], A[2], ..., A[N] (1 ≤ A[i] ≤ 10^6).
- Then M lines follow, each with three integers V, x, y (1 ≤ V ≤ 1000, 1 ≤ x ≤ y ≤ N).

Output
For each test case, print:
- A line: Case #k
- Then print M lines, each containing the answer for the corresponding query.
- Print a blank line between two consecutive test cases.

Sample Input
2
5 2
1 2 3 4 6
2 1 5
5 1 4
5 2
2 3 5 3 7
3 2 4
5 1 5

Sample Output
Case #1
12
0

Case #2
6
5

Explanation
- Query 1 of Case #1: In A[1..5], the divisible-by-2 elements are {2, 4, 6}; their sum is 12.
- Query 2 of Case #1: In A[1..4], there are no elements divisible by 5; the sum is 0.

Note
Data set is large. Use fast I/O.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Minimum Distinct People Seen

You are the guard of a shop. Over time, people enter and leave. You record a binary string s:

- s[i] = '1'  → a person enters at time i
- s[i] = '0'  → a person leaves at time i

A person may enter and leave any number of times.
Using only this information, determine the minimum possible number of distinct people you might have seen.

Task:
Given s, compute the smallest number of distinct individuals consistent with the sequence of enters/leaves.

Input:
- A single binary string s (1 ≤ |s| ≤ 10^5)

Output:
- A single integer: the minimum possible number of distinct people seen.

Constraints:
- 1 ≤ len(s) ≤ 10^5
- s consists only of characters '0' and '1'

Notes:
- Multiple test strings may be provided one per line (if desired), each to be processed independently.

Examples:

Example 1
Input:
000
Output:
3
Explanation:
t=1: person A leaves
t=2: person B leaves
t=3: person C leaves
Thus 3 distinct people.

Example 2
Input:
110011
Output:
2
Explanation:
t=1: P1 enters
t=2: P2 enters
t=3: P1 leaves
t=4: P2 leaves
t=5: P1 enters
t=6: P2 enters
Minimum distinct people = 2.

Example 3
Input:
10101
Output:
1
Explanation:
One person alternates entering and leaving; only 1 distinct person is needed.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Count Good Strings

You are given a string s of length n (1 ≤ n ≤ 10^4).  
Each character of s is either a digit '0'–'9' or a question mark '?'.

You may replace every '?' with any digit from 0 to 9.  
A string is called GOOD if, when interpreted as a (possibly leading-zero) decimal number, it leaves remainder 7 when divided by 11 AND also leaves remainder 7 when divided by 13.

Task:
Count how many different strings can be obtained by replacing '?' such that the resulting number is GOOD.

Notes:
- Leading zeros are allowed (unless otherwise specified).
- Equivalently, a GOOD string represents a number congruent to 7 modulo 11 and 13 (i.e., modulo 143).

Input:
A single line containing the string s.

Output:
A single integer — the number of GOOD strings.

Constraints:
1 ≤ n ≤ 10^4  
s[i] ∈ {'0','1',…,'9','?'}

Examples:

Example 1
Input:
??756
Output:
1
Explanation:
Only one completion works: 34756.

Example 2
Input:
??33?
Output:
10
Explanation:
There are 10 completions such that the number is ≡ 7 mod 11 and ≡ 7 mod 13 (e.g., 42335, 46339, and 8 others).


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem: Largest Contiguous Subarray (Lexicographic)

Definition:
- For two arrays A and B of the same length, A > B if at the first index where they differ,
  A[i] > B[i]. (This is standard lexicographic order.)
- A contiguous subarray uses consecutive indices.

Task:
Given an integer array arr of length n and an integer k (1 ≤ k ≤ n),
return (or print) the lexicographically largest contiguous subarray of length k
among all subarrays arr[i..i+k-1] (0 ≤ i ≤ n-k).

Input Format:
- Line 1: integer n
- Line 2: n space-separated integers arr[i]
- Line 3: integer k

Output Format:
- One line with k space-separated integers: the lexicographically largest contiguous subarray of length k.

Constraints:
- 1 ≤ k ≤ n ≤ 100
- 1 ≤ arr[i] ≤ 1000

Example:
Input
5
1 4 3 2 5
4

Output
4 3 2 5

Explanation:
Possible subarrays of size 4: [1,4,3,2] and [4,3,2,5].
Comparing lexicographically, [4,3,2,5] is larger.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Interesting Pairs of Numbers

Given an array of integers arr and an integer sumVal, count the number of unordered
index pairs (i, j) with i < j such that:

    |arr[i] - arr[j]| + |arr[i] + arr[j]| = sumVal

An unordered pair (i, j) is called “interesting” if it satisfies the above condition.

Example:
- arr = [1, 4, -1, 2]
- sumVal = 4
Interesting pairs: (1,4) and (3,4)
Because:
|arr1 - arr4| + |arr1 + arr4| = |1 - 2| + |1 + 2| = 4
|arr3 - arr4| + |arr3 + arr4| = |-1 - 2| + |-1 + 2| = 4

Function Description
Complete the function:
    long long findInterestingPairs(const vector<int>& arr, int sumVal);

Parameters:
- arr[n]: array of integers
- sumVal: integer

Returns:
- A single integer/long long: the number of interesting pairs.

Constraints:
- 1 ≤ n ≤ 1e5
- -1e6 ≤ arr[i] ≤ 1e6
- 1 ≤ sumVal ≤ 1e6

Input Format (for custom testing):
n
arr[0]
arr[1]
...
arr[n-1]
sumVal

Output Format:
A single integer: the count of interesting pairs.

Sample Input 0:
4
1
3
2
0
2

Sample Output 0:
1

Explanation:
Only one interesting pair: (1,4),
since |1 - 0| + |1 + 0| = 1 + 1 = 2.

Sample Input 1:
4
1
4
-1
2
4

Sample Output 1:
2

Explanation:
Pairs (1,4) and (3,4) satisfy the condition (shown above).


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Women Leading

Shakuntala Devi once asked her students sitting in a lecture room to analyze seating rows.
For each row (a string consisting only of 'W' for Women and 'M' for Men), determine the
maximum length of a contiguous block that consists of k consecutive 'W' followed immediately
by k consecutive 'M' (for some k ≥ 1). In other words, find the longest substring of the
form W^k M^k and report its length (which is 2k). If no such substring exists, print -1.

Input Format
- The first line contains an integer R — the number of rows.
- Each of the next R lines contains a string S made up of only 'W' and 'M'.

Output Format
- For each row, print a single integer: the maximum length of a substring of the form
  W^k M^k (k ≥ 1); print -1 if it is not possible.

Constraints
- 1 ≤ R ≤ 10
- 1 ≤ |S| ≤ 10^5

Sample Input
2
WWMMMWMWMMMMMWWWWWWWWMMW
MMMWW

Sample Output
6
-1

Explanation
Row 1: The longest contiguous block of Women followed by Men with equal counts is "WWWMMM",
so the length is 6.
Row 2: There is no substring of the form W^k M^k, hence -1.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Maximum Partition

You are given an array A of N integers (1-based indexing). You may split the array into any number K (K ≥ 1) of
contiguous partitions so that together they cover the whole array in order.

If the partition sums are P1, P2, …, PK, define the “special sum” of the partitioning as:
    P1 − P2 + P3 − P4 + … + (−1)^(K−1) · PK
(i.e., start with +, then alternate −, +, −, …).

Task
Choose a partitioning that maximizes the special sum and output that maximum value.

Notes
• Partitions must be contiguous and in order (no reordering of elements).
• 1-based indexing is assumed in any explanation.

Input Format
• The first line contains an integer N.
• The second line contains N space-separated integers A1, A2, …, AN.

Output Format
• Print a single integer: the maximum achievable special sum.

Constraints
• 1 ≤ N ≤ 10^5
• −10^5 ≤ Ai ≤ 10^6  for all i in [1, N]

Example
Input
5
-1 -2 3 2 9

Output
9

Explanation
One optimal partitioning is: [−1] | [−2, 3] | [2, 9]
Here, P1 = −1, P2 = (−2 + 3) = 1, P3 = (2 + 9) = 11
Special sum = P1 − P2 + P3 = (−1) − 1 + 11 = 9

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Interleaving Subsequences Count

Given three lowercase strings p, q, and r (length ≤ 100), count the number of ways to form
exactly the string r by interleaving a subsequence of p and a subsequence of q, while
preserving the relative order of characters taken from each string. You must use at least
one character from p and at least one character from q. Return the answer modulo 1,000,000,007.

Notes
- “Subsequence” means you may skip characters but cannot reorder them.
- The two chosen subsequences (one from p, one from q) are interleaved to form r.
- At least one character must be taken from each of p and q.

Input Format
- Line 1: string p
- Line 2: string q
- Line 3: string r

Output Format
- A single integer: the number of valid interleavings modulo 1,000,000,007.

Constraints
- 1 ≤ |p|, |q|, |r| ≤ 100
- All strings consist only of lowercase English letters.

Sample
p: ab
q: ba
r: aba

Output:
2

Explanation:
Two valid ways to form "aba":
1) take "a" from p, then "ba" from q
2) take "ab" from p, then "a" from q


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Maximize Subarray-Sum × Pivot Value

Given an array arr of length n, find the maximum possible value of:
    ( sum(arr[i..j]) ) × arr[k]
over all choices of indices i, j, k such that 0 ≤ i ≤ k ≤ j < n.

Input Format
- Line 1: integer n
- Line 2: n space-separated integers arr[0], arr[1], …, arr[n-1]

Output Format
- Print a single integer: the maximum value of (sum of a subarray) multiplied by
  the value at some index k that lies inside that subarray.
  Use 64-bit arithmetic for safety.

Constraints
- 1 ≤ n ≤ 5 × 10^5
- −10^6 ≤ arr[i] ≤ 10^6

Example
Input
5
2 -1 3 -2 4
Output
16

Explanation
Best is to choose subarray [0..4] with sum 6 and k = 4 (arr[k] = 4):
6 × 4 = 24; but even better is subarray [2..4] with sum 5 and k = 4: 5 × 4 = 20.
(Your result should be the maximum over all valid (i, j, k); values can be negative too.)


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem — Minimize Spread After 4-Way Split

You are given an integer N and an array X of N integers (X1 … XN).
Place exactly three cut positions to split X into four **non-empty, contiguous**
subarrays. Let A, B, C, and D be the sums of those four parts (in order).

Your task is to output the **minimum possible value** of:
    max(A, B, C, D) − min(A, B, C, D)

Input Format
• N
• X1 X2 … XN

Output Format
• A single integer: the minimum possible value of max(A,B,C,D) − min(A,B,C,D).

Constraints
• 4 ≤ N ≤ 2⋅10^5
• 0 ≤ Xi ≤ 10^9

Sample 1
Input
5
4 3 5 2 3
Output
2
Explanation
Split as (4) | (3) | (5) | (2,3) → A=4, B=3, C=5, D=5 → 5 − 3 = 2.

Sample 2
Input
7
3 2 1 11 12 5 9
Output
7

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem — Max Equalizable Count with ±1 Operations

You are given an array A of N integers.

For each element Ai you may perform exactly one of the following:
• Add 1 to Ai
• Subtract 1 from Ai
• Do nothing to Ai

After applying these choices to all elements, you may choose any integer K.
Count how many elements are equal to K. Your task is to find the **maximum**
possible count.

Input Format
• The first line contains a single integer N.
• The second line contains N integers: A1 A2 … AN.

Constraints
• 1 ≤ N ≤ 100000
• 0 ≤ Ai ≤ 100000

Output Format
• Print a single integer — the maximum possible number of elements that can be made equal to some K.

Sample
Input
7
3 1 4 1 5 9 2
Output
4
Explanation
Choose K = 2. Values originally equal to 1, 2, or 3 can be turned into 2.
There are 2 (ones) + 1 (two) + 1 (three) = 4 such elements.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Playlist Fun Maximization

You have n songs. The i-th song has:
  - singer[i]: an integer ID of its singer
  - length[i]: its duration (positive integer)

You may reorder the songs arbitrarily. While listening, the fun gained from the
t-th played song equals:
    (# of distinct singers heard among the first t songs) × length of that song.

Goal:
Choose an order that maximizes the total fun
    sum_{t=1..n} (distinct_singers_so_far) * length[ song_at_position_t ],
and return that maximum value.

Constraints
1 ≤ n ≤ 10^5
1 ≤ singer[i] ≤ 10^9
1 ≤ length[i] ≤ 10^9

Example 1
n = 3
singer = [1, 2, 2]
length = [2, 3, 2]
Optimal order: first song (1,2), third song (2,2), second song (2,3)
Fun: 1*2 + 2*2 + 2*3 = 2 + 4 + 6 = 12
Answer: 12

Example 2
n = 3
singer = [1, 1, 2]
length = [5, 4, 3]
Optimal order: second song (1,4), third song (2,3), first song (1,5)
Fun: 1*4 + 2*3 + 2*5 = 4 + 6 + 10 = 20
Answer: 20


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Arranging Numbers (Beautiful Arrangement)

Jayme has the numbers 1..n. A permutation a[1..n] (1-based) is called
“beautiful” if for every position i (1 ≤ i ≤ n) at least one holds:
  - a[i] is divisible by i, OR
  - i is divisible by a[i].
(i.e., a[i] % i == 0 or i % a[i] == 0)

Task:
Count how many beautiful permutations of {1, 2, …, n} exist and return that count.

Input
- A single integer n

Output
- A single integer: the number of beautiful arrangements

Constraints
- 1 < n < 20

Example
Input:
2
Output:
2
Explanation:
Permutations [1,2] and [2,1] both satisfy the divisibility condition at each position.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Element Swapping

Given an array arr of n integers, you may perform the following operation any number of times:
1) Choose an index i (0 ≤ i < n − 1) and swap arr[i] and arr[i + 1].
2) Each element can be swapped at most once during the whole process (i.e., no element participates in more than one swap).

The strength of index i is defined as arr[i] × (i + 1), using 0-based indexing.

Goal:
Find the maximum possible value of
    S = Σ_{i=0}^{n−1} arr[i] × (i + 1)
after applying allowed swaps optimally. Return this maximum.

Example
n = 4
arr = [2, 1, 4, 3]

Optimal swaps:
- swap(arr[2], arr[3])
- swap(arr[0], arr[1])

Final array: [1, 2, 3, 4]
Sum of strengths: 1×1 + 2×2 + 3×3 + 4×4 = 30
Return 30.

Function Description
Complete the function getMaximumSumOfStrengths with the parameter:
    int arr[n]: the initial array
Returns:
    long int: the maximum possible sum of strengths of all indices after optimal swaps.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Maximum Number of Servers Within Budget

Problem Statement
You are given two 0-indexed integer arrays of equal length: bootCost and runCost.
There are n servers in a line. If you run a consecutive group of k servers from
index l to r (k = r - l + 1), the total cost is:

  total_cost(l, r) = max(bootCost[l..r]) + k * sum(runCost[l..r]) + overhead * (k - 1)

where:
- max(bootCost[l..r]) is the largest activation cost in the window [l..r],
- sum(runCost[l..r]) is the sum of running costs in that window,
- overhead is a fixed non-negative integer penalty paid per additional server
  beyond the first in the block (so there are k-1 such links).

You are also given an integer budget.
Return the maximum number k of consecutive servers you can run such that the total
cost does not exceed budget. If no window is affordable, return 0.

Input Format
- Line 1: n
- Line 2: n integers — bootCost[0], bootCost[1], ..., bootCost[n-1]
- Line 3: n integers — runCost[0], runCost[1], ..., runCost[n-1]
- Line 4: two integers — budget and overhead

Output Format
- One integer: the maximum k (length of a contiguous block) that fits within the budget.

Example
Input
5
3 6 1 3 4
2 1 3 4 5
30 1

Output
3


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Challenge: Longest Symmetric Substring with Replacements

Definition
A string is called symmetric if its length is even, the first half consists only of '<'
characters, and the second half consists only of '>' characters.
Examples of symmetric strings: "" (empty string), "<>", "<<>>", "<<<>>>", ...

Task
Given a string S consisting of the characters '<', '>' and/or '?', you may replace each
'?' with either '<' or '>' (independently). Return the length of the longest **contiguous**
substring of S that can be made symmetric after such replacements.

Function signature
int solution(string &S);

Examples
1) S = "<><??>>"
   After replacing all '?' with '<', we get "<<<<<<>". The longest symmetric substring is "<<>>",
   so the function should return 4.

2) S = "??????"
   Replace the first three '?' with '<' and the next three with '>' -> "<<<>>>".
   The function should return 6.

3) S = "<<"
   The function should return 2.

Notes
- |S| is in the range [1 .. 200,000].
- S contains only the characters '<', '>' and '?'.
- Aim for an efficient algorithm.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Lucky Triples

You are given an array a[1..n] of positive integers. Count the number of index triples (i, j, k) such that
  1 ≤ i < j < k ≤ n,
  a[i] divides a[j], and
  a[j] divides a[k].

Print the total number of such triples.

Input
- The first line contains an integer n (1 ≤ n ≤ 2⋅10^5).
- The second line contains n integers a1, a2, …, an (1 ≤ ai ≤ 10^6).

Output
- Print a single integer: the number of triples (i, j, k) with i < j < k, a[i] | a[j], and a[j] | a[k].

Notes
- Use 64-bit integer type for the answer (e.g., long long in C++), as the count can be large.
- Values can repeat; equal values are allowed.

Example 1
Input
4
1 2 2 4

Output
4

Explanation
Valid triples (1-based indices): (1,2,3), (1,2,4), (1,3,4), (2,3,4).

Example 2
Input
6
1 2 3 4 6 12

Output
10

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

C. Maximum Median

You are given an array a of n integers, where n is odd. You can perform the following operation:

- Choose one element of the array (say ai) and increase it by 1 (replace ai with ai + 1).

You want to make the median of the array as large as possible using at most k operations.

Definition:
The median of an odd-sized array is the middle element after the array is sorted in non-decreasing order.
Example: the median of [1, 5, 2, 3, 5] is 3.

Input
The first line contains two integers n and k (1 ≤ n ≤ 2⋅10^5, n is odd, 1 ≤ k ≤ 10^9).
The second line contains n integers a1, a2, …, an (1 ≤ ai ≤ 10^9).

Output
Print a single integer — the maximum possible median after at most k operations.

Examples

Input
3 2
1 3 5
Output
5

Input
5 5
1 2 1 1 1
Output
3

Input
7 7
4 1 2 4 3 4 4
Output
5

Note
- In the first example, you can increase the second element twice to get [1, 5, 5]; median is 5.
- In the second example, increasing the second, third, and fifth elements appropriately yields a median of 3.
- In the third example, increasing the first, fourth, sixth, and seventh elements yields a median of 5.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Time limit: 1.00 s
Memory limit: 512 MB

Problem — Josephus (k-step elimination)

There are n children (numbered 1..n) standing in a circle. Repeatedly, k children are skipped and then the next child is removed from the circle. Determine the order in which the children are removed.

Input
The only input line has two integers n and k.

Output
Print n integers: the removal order.

Constraints
1 ≤ n ≤ 2 · 10^5
0 ≤ k ≤ 10^9

Example
Input:
7 2

Output:
3 6 2 7 5 1 4


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Minimum Total Idle Time (Servers → Tasks)

You have N servers. Each server i takes A[i] time to finish its process.

You must create tasks that use increasing numbers of servers exactly once:
Task 1 uses 1 server
Task 2 uses 2 servers
Task 3 uses 3 servers
…
Task K uses K servers

All servers must be used exactly once. Therefore, N must be a triangular number:
N = 1 + 2 + … + K = K*(K+1)/2
(If no such K exists, output -1.)

For any task (i.e., any chosen group of servers), its idle time is:
idle(group) = max(time in group) − min(time in group)

Goal:
Partition the N servers into K groups of sizes 1,2,…,K so that the sum of idle times
over all groups is minimized. Return that minimum total idle time.

Input:
T                       // number of test cases
For each test case:
  N                     // number of servers
  A1 A2 … AN            // times of the N servers

Output:
For each test case, print a single integer: the minimum possible sum of idle times
(OR -1 if it is impossible to form groups of sizes 1..K that use all servers).

Constraints:
1 ≤ T ≤ 10
1 ≤ N ≤ 1000
1 ≤ A[i] ≤ 10^9
Sum of N over all test cases ≤ 2000

Sample Input:
1
6
1 2 2 2 3 3

Sample Output:
4

Explanation (one optimal partition when N=6 = 1+2+3):
Group sizes: 1 | 2 | 3
Choose (2) | (2,2) | (1,3,3)
Idle times: 0  +  0   +  (3−1)=2  → total 2
Another optimal partition yields total 4 overall minimum across valid partitions is 4.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Compatible Warehouse Pairs in a Weighted Tree

You are given a weighted, undirected tree of N warehouses (nodes), rooted at node 1.
Each edge (u, v) has a positive distance w. For every node v (1-based), you are also given
an integer val[v].

Define distance(u, v) as the sum of edge weights on the unique path between u and v.

A pair (u, v) is called compatible if:
  • u is an ancestor of v in the rooted tree (u lies on the path from 1 to v, u ≠ v), and
  • distance(u, v) ≤ val[v].

Task:
Count the total number of compatible pairs (u, v).

Input Format:
  N
  (N-1) lines follow: u v w      // 1 ≤ u, v ≤ N, edge weight w > 0
  final line: val1 val2 ... valN // values for nodes 1..N

Output Format:
  Print a single integer — the number of compatible pairs.

Notes:
  • The tree is rooted at node 1.
  • Edges are undirected; weights are positive.
  • All node indices are 1-based.

Example
Input:
6
1 6 4
6 5 1
1 2 3
1 4 2
4 3 1
2 1 3 1 5 4

Output:
5

Explanation:
Compatible pairs are:
(1, 6): distance(1,6)=4 ≤ val[6]=4
(1, 5): distance(1,5)=4+1=5 ≤ val[5]=5
(6, 5): distance(6,5)=1 ≤ val[5]=5
(4, 3): distance(4,3)=1 ≤ val[3]=3
(1, 3): distance(1,3)=2+1=3 ≤ val[3]=3
Total = 5.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Title: One-Block Partitions

You are given a binary array Arr of length N (elements are only 0 or 1).

Definition:
A “One block” is a continuous subarray that contains exactly one element equal to 1.

Task:
Partition the entire array Arr into contiguous blocks so that every block is a One block.
Return the total number of different valid partitions. If it is impossible, return 0.

Notes:
- Blocks must cover the whole array without overlap.
- Two partitions are different if they place at least one cut in a different position.

Input
- N : integer, the size of the array (1 ≤ N ≤ 100)
- Arr : N space-separated integers (each 0 or 1)

Output
- A single integer: the number of ways to divide the array into One blocks.

Example 1
Input
3
0 1 0
Output
1
Explanation
The only valid partition is the whole array [0,1,0], which contains exactly one ‘1’.

Example 2
Input
6
1 0 0 1 0 1
Output
6
Explanation
Ones at positions 1,4,6. Zeros between consecutive ones are 2 and 1, so ways = (2+1)*(1+1) = 6.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Title: Unpurchased Categories

There are n items on a website, indexed 0..n-1. The category id of item i is
category[i] (an integer). There are m customers. Customer j buys every item
from index l to r inclusive, given as purchase[j] = [l, r].

Task
Return all DISTINCT category ids for which **no item of that category was ever
purchased by any customer**. Sort the result in ascending order. If every
category had at least one item purchased, return [-1].

Function
vector<int> getUnpurchasedCategories(vector<int> category,
                                     vector<vector<int>> purchase)

Input (custom testing)
n
category[0]
category[1]
...
category[n-1]
m
purchase[0][0] purchase[0][1]
purchase[1][0] purchase[1][1]
...
purchase[m-1][0] purchase[m-1][1]

Output
A line with the desired category ids in ascending order (or -1 if none).

Constraints
1 ≤ n ≤ 1e5
1 ≤ category[i] ≤ 1e9
0 ≤ m ≤ 1e5
0 ≤ purchase[j][0] ≤ purchase[j][1] < n

Example
n = 5
category = [1, 2, 5, 4, 5]
m = 3
purchase = [[0, 1], [0, 2], [1, 2]]

Items purchased cover indices {0,1,2}; thus categories purchased are {1,2,5}.
Category 4 never appears among purchased indices → answer: [4].

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Title: Assign Requests to Least-Loaded Servers

You have N servers labeled 1..N. Initially, each server’s total load is 0.
There are M incoming requests; the i-th request has load requests[i].

Assignment rule for each request (in order):
1) Choose the server with the smallest current total load.
2) If multiple servers tie, choose the one with the smallest label.
3) Assign the request to that server and increase that server’s load by the request’s load.

Task
Return an array of length M where the i-th element is the label of the server that handles the i-th request.

Input (for custom testing)
N
M
requests[0] requests[1] ... requests[M-1]

Output
M lines, each with the label (1..N) of the server that handled the corresponding request.

Constraints
1 ≤ N ≤ 2 * 10^5
1 ≤ M ≤ 2 * 10^5
0 ≤ requests[i] ≤ 10^9

Notes / Hint
Use a min-heap (priority queue) of (current_load, label) to always pop the least-loaded server; this
automatically breaks ties by smallest label.

Example
Input
2
2
5 5
Output
1
2
Explanation:
Start loads: (0,#1), (0,#2). First request -> #1 (tie broken by smallest label).
Loads become (5,#1), (0,#2). Second request -> #2. Final assignment sequence: [1, 2].


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem Statement:
You are given an integer array arr of length n.
You can perform the following operation exactly k times:

1. Choose any index i (0 ≤ i < n) and add arr[i] to your total score.
2. After choosing i, discard either all elements to the left of i (arr[0..i−1])
   or all elements to the right of i (arr[i+1..n−1]).
   The remaining part becomes the new array for the next operation.

Your task is to maximize the total score after exactly k operations.

Example:
Input:
n = 6
arr = [4, 6, -10, -1, 10, -20]
k = 4

Process:
1. Choose arr[4] = 10 → keep left → arr = [4, 6, -10, -1], score = 10
2. Choose arr[0] = 4 → keep right → arr = [6, -10, -1], score = 14
3. Choose arr[0] = 6 → keep right → arr = [-10, -1], score = 20
4. Choose arr[1] = -1 → keep right → arr = [ ], score = 19

Output:
19

Explanation:
Each time you pick an element, you can only continue from one side.
However, any subset of k elements can be picked if you always choose
from the extremes of your target indices.
Therefore, the maximum total score equals the sum of the k largest
elements in the array.

Constraints:
1 ≤ n ≤ 10⁵
−10⁹ ≤ arr[i] ≤ 10⁹
1 ≤ k ≤ n


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem — Count Beautiful Subarrays

You are given an array A of length n (0-indexed). A subarray is called “beautiful” if:
• Its length is odd (always beautiful), OR
• Its length is even and the two middle elements are equal.

Formally, for a subarray A[l..r] with length L = r − l + 1:
• If L is odd → beautiful.
• If L is even → beautiful iff A[l + L/2 − 1] == A[l + L/2].

Your task is to count the total number of beautiful subarrays of A.

Input
• n — the length of the array (1 ≤ n ≤ 2⋅10^5)
• A1, A2, …, An — the array elements (1 ≤ Ai ≤ 10)

Output
• A single integer: the number of beautiful subarrays.

Example
Input:
5
3 1 2 2 4

Output:
11

Explanation (informal):
All odd-length subarrays are beautiful. Among even-length subarrays, only those whose two middle elements are equal are counted (e.g., [1,2,2,4] has middle elements 2 and 2).



XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Minimum Shifts

Given an n×m binary matrix mat (provided as an array of strings of length m),
you may perform row operations. In one operation you can cyclically shift a single
row by 1 position either to the left or to the right (wrapping around). Each 1-step
shift counts as cost 1.

Task:
Find the minimum total number of shifts needed so that there exists at least one
column whose cells are all '1'. If it is impossible, return -1.

Notes:
• mat[i] is the i-th row; all rows have equal length m.
• A cyclic left shift moves each character one position left and the first character
  goes to the end. A cyclic right shift moves each character one position right and
  the last character goes to the front.

Function to implement:
int findMinimumShifts(vector<string> mat);

Return:
An integer — the minimum number of shifts required to make at least one column
all '1', or -1 if not possible.

Constraints:
1 ≤ n ≤ 10000
1 ≤ m ≤ 1000
Each mat[i] consists only of characters '0' and '1'.

Input format (for custom testing):
Line 1: n
Next n lines: each line is a binary string of length m describing a row of the matrix.

Output (for custom testing):
Single integer — the answer.

Example 1:
Input
4
0101
1010
0100
0001
Output
3
Explanation
Rotate row 1 right (0101→1010), row 3 right (0100→0010), row 4 left (0001→0010).
Then column 3 becomes all '1'. Total shifts = 3.

Example 2:
Input
3
111
101
000
Output
-1
Explanation
The third row is all zeros, so no column can be made all '1'.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
