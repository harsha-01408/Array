782. Avoid "suspected robbery"

Small towns are distributed along the street (which can be understood as all on the number axis), with N banks (the location is represented by the coordinates of the number axis, and the amount represents the amount that can be robbed).

The two kidnappers tried to rob a bank each, and in order to get the police to travel more, they agreed to choose two banks not less than apart D.

Excuse me, what is the maximum total amount they can grab if they meet the agreement.

Input format
Input contains N + 1 lines.

The first line contains two integers N and D, indicating the number of banks and the agreed distance respectively.

Next N lines, each containing two integers A and B, indicating the coordinates and the amount respectively.

Output format
Output a number indicating the maximum amount that can be obtained.

Data scope
1 ≤ N ≤ 2 × 10^5
1 ≤ D, A, B ≤ 10^8

The data guarantee that at least two banks are present at a distance of not less than D.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

1454. Number of Subsets with Prime XOR Sum

You are given n distinct positive integers.

Count how many subsets of these integers have their XOR-sum equal to a prime number.

Since the answer can be very large, output it modulo 10^9 + 7.

Input

The first line contains an integer n.

The second line contains n distinct positive integers.

Output

Output a single integer — the number of subsets whose XOR-sum is prime, modulo 10^9 + 7.

Constraints

1 ≤ n ≤ 5000

1 ≤ each integer ≤ 5000

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

756. Serpentine Matrix

Enter two integers N and M, output an N × M matrix.
Fill the numbers from 1 to N × M into the matrix in a backward serpentine (spiral) order.

You can refer to the sample example for the specific filling pattern.

Input format

A single line containing two integers N and M.

Output format

Output an N × M matrix that meets the requirement.

The matrix has N rows, and each row contains M integers separated by spaces.

Data constraints

1 ≤ N, M ≤ 100

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXxxxxxxxxxxxxxxxxxx

Problem 1487: Coin Selection

Problem Statement:
You are given n1 + n2 types of coins. 
- The first n1 types are ordinary coins, which you can pick any number of times.
- The next n2 types are commemorative coins, of which you can pick at most 1 coin of each type. 
Each coin has a positive integer face value.  

Your task is to find the number of ways to form a total sum of exactly m using these coins. 
Output the result modulo 10^9 + 7.

Input Format:
- First line: three integers n1, n2, m 
  (number of ordinary coins, number of commemorative coins, target sum)
- Second line: n1 integers a[1..n1], the face values of ordinary coins (strictly increasing)
- Third line: n2 integers b[1..n2], the face values of commemorative coins (strictly increasing)

Output Format:
- One integer x: the total number of ways to form sum m modulo 10^9 + 7.

Constraints:
- For 30% of data: 1 ≤ n1+n2 ≤ 10, 1 ≤ m ≤ 100, 1 ≤ a[i], b[i] ≤ 100
- For 100% of data: 1 ≤ n1+n2 ≤ 100, 1 ≤ m ≤ 100000, 1 ≤ a[i], b[i] ≤ 100000

Sample Input:
3 1 5
1 2 3
1

Sample Output:
9

Explanation:
(x) denotes ordinary coins, [x] denotes commemorative coins. All ways to make sum 5:
(1)(1)(1)(1)(1)
(1)(1)(1)(2)
(1)(1)(3)
(1)(2)(2)
(2)(3)
(1)(1)(1)(1)[1]
(1)(1)(1)(2)

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

730. Robot Jumping Problem

A robot is playing an old DOS-based game.

In the game, there are N+1 buildings indexed from 0 to N, arranged from left to right.

The height of building 0 is 0 units.

The height of building i (where i ≥ 1) is given by H(i) units.

Initially, the robot starts at building 0.

At each step, the robot jumps to the next building (i.e., from building k to building k+1).

Energy Requirement:

Assume the robot is at building k and its current energy is E.

When it jumps to building k+1, if the height of building k+1 (H(k+1)) is greater than E, the robot loses energy equal to the difference H(k+1) - E.

If the height of building k+1 is less than or equal to E, the robot gains energy equal to E - H(k+1).

Goal:

The robot’s goal is to reach building N. The robot’s energy should never go below 0 during the journey.

Problem:

Given the heights of the buildings, find the minimum initial energy E the robot must have in order to reach building N without ever running out of energy.

Input Format:

The first line contains an integer N.

The second line contains N integers, representing the heights of the buildings (from building 1 to building N).

Output Format:

Output the minimum initial energy E (rounded up to the nearest integer) required for the robot to reach building N.

Constraints:

1 ≤ N ≤ 100,000

1 ≤ H(i) ≤ 1,000,000,000

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem Description:

In a small town, there are n banks, and each bank is located along a straight line (on the number axis). Each bank has a position and an amount of money that can be stolen from them.

Two robbers are trying to rob two different banks. However, to make the police chase them more effectively, they agree that the distance between the two banks they rob must be at least d.

Your task is to determine the maximum amount of money they can steal while following the constraint of the minimum distance between the two robbed banks.

Input Format:

The first line contains two integers n and d, representing the number of banks and the minimum distance between the two banks that the robbers can rob.

The next n lines each contain two integers:

a: The position of a bank on the number line.

b: The amount of money available at that bank, respectively.

Output Format:

Output a single integer, which is the maximum total amount of money the two robbers can steal.

Constraints:

1 ≤ n ≤ 200,000

1 ≤ d, a, b ≤ 100,000,000

Note: It is guaranteed that there are at least two banks whose distance is not less than d.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

NAJ0001 - Divisible Number Sum

Hazzat is a new guy in computer science, now in his 3rd semester. He recently completed a data structures course but keeps encountering problems he can't solve with the structures he knows. He wants to establish a new data structure but keeps failing. Help Hazzat by solving the following problem.

You are given an array A of N integers. You need to answer M queries.

Each query is of the form: V x y

For each query, consider the subarray A[x..y] (1-based indices). Let S be the subset of elements in this range that are fully divisible by V; i.e., include A[i] in S if x ≤ i ≤ y and A[i] % V == 0. Output the sum of all elements in S.

Input
- The first line contains an integer T (1 ≤ T ≤ 5) — the number of test cases.
For each test case:
- A line with two integers N and M (1 ≤ N ≤ 10^5, 1 ≤ M ≤ 2×10^5).
- A line with N integers: A[1], A[2], ..., A[N] (1 ≤ A[i] ≤ 10^6).
- Then M lines follow, each with three integers V, x, y (1 ≤ V ≤ 1000, 1 ≤ x ≤ y ≤ N).

Output
For each test case, print:
- A line: Case #k
- Then print M lines, each containing the answer for the corresponding query.
- Print a blank line between two consecutive test cases.

Sample Input
2
5 2
1 2 3 4 6
2 1 5
5 1 4
5 2
2 3 5 3 7
3 2 4
5 1 5

Sample Output
Case #1
12
0

Case #2
6
5

Explanation
- Query 1 of Case #1: In A[1..5], the divisible-by-2 elements are {2, 4, 6}; their sum is 12.
- Query 2 of Case #1: In A[1..4], there are no elements divisible by 5; the sum is 0.

Note
Data set is large. Use fast I/O.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Minimum Distinct People Seen

You are the guard of a shop. Over time, people enter and leave. You record a binary string s:

- s[i] = '1'  → a person enters at time i
- s[i] = '0'  → a person leaves at time i

A person may enter and leave any number of times.
Using only this information, determine the minimum possible number of distinct people you might have seen.

Task:
Given s, compute the smallest number of distinct individuals consistent with the sequence of enters/leaves.

Input:
- A single binary string s (1 ≤ |s| ≤ 10^5)

Output:
- A single integer: the minimum possible number of distinct people seen.

Constraints:
- 1 ≤ len(s) ≤ 10^5
- s consists only of characters '0' and '1'

Notes:
- Multiple test strings may be provided one per line (if desired), each to be processed independently.

Examples:

Example 1
Input:
000
Output:
3
Explanation:
t=1: person A leaves
t=2: person B leaves
t=3: person C leaves
Thus 3 distinct people.

Example 2
Input:
110011
Output:
2
Explanation:
t=1: P1 enters
t=2: P2 enters
t=3: P1 leaves
t=4: P2 leaves
t=5: P1 enters
t=6: P2 enters
Minimum distinct people = 2.

Example 3
Input:
10101
Output:
1
Explanation:
One person alternates entering and leaving; only 1 distinct person is needed.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Count Good Strings

You are given a string s of length n (1 ≤ n ≤ 10^4).  
Each character of s is either a digit '0'–'9' or a question mark '?'.

You may replace every '?' with any digit from 0 to 9.  
A string is called GOOD if, when interpreted as a (possibly leading-zero) decimal number, it leaves remainder 7 when divided by 11 AND also leaves remainder 7 when divided by 13.

Task:
Count how many different strings can be obtained by replacing '?' such that the resulting number is GOOD.

Notes:
- Leading zeros are allowed (unless otherwise specified).
- Equivalently, a GOOD string represents a number congruent to 7 modulo 11 and 13 (i.e., modulo 143).

Input:
A single line containing the string s.

Output:
A single integer — the number of GOOD strings.

Constraints:
1 ≤ n ≤ 10^4  
s[i] ∈ {'0','1',…,'9','?'}

Examples:

Example 1
Input:
??756
Output:
1
Explanation:
Only one completion works: 34756.

Example 2
Input:
??33?
Output:
10
Explanation:
There are 10 completions such that the number is ≡ 7 mod 11 and ≡ 7 mod 13 (e.g., 42335, 46339, and 8 others).


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem: Largest Contiguous Subarray (Lexicographic)

Definition:
- For two arrays A and B of the same length, A > B if at the first index where they differ,
  A[i] > B[i]. (This is standard lexicographic order.)
- A contiguous subarray uses consecutive indices.

Task:
Given an integer array arr of length n and an integer k (1 ≤ k ≤ n),
return (or print) the lexicographically largest contiguous subarray of length k
among all subarrays arr[i..i+k-1] (0 ≤ i ≤ n-k).

Input Format:
- Line 1: integer n
- Line 2: n space-separated integers arr[i]
- Line 3: integer k

Output Format:
- One line with k space-separated integers: the lexicographically largest contiguous subarray of length k.

Constraints:
- 1 ≤ k ≤ n ≤ 100
- 1 ≤ arr[i] ≤ 1000

Example:
Input
5
1 4 3 2 5
4

Output
4 3 2 5

Explanation:
Possible subarrays of size 4: [1,4,3,2] and [4,3,2,5].
Comparing lexicographically, [4,3,2,5] is larger.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Interesting Pairs of Numbers

Given an array of integers arr and an integer sumVal, count the number of unordered
index pairs (i, j) with i < j such that:

    |arr[i] - arr[j]| + |arr[i] + arr[j]| = sumVal

An unordered pair (i, j) is called “interesting” if it satisfies the above condition.

Example:
- arr = [1, 4, -1, 2]
- sumVal = 4
Interesting pairs: (1,4) and (3,4)
Because:
|arr1 - arr4| + |arr1 + arr4| = |1 - 2| + |1 + 2| = 4
|arr3 - arr4| + |arr3 + arr4| = |-1 - 2| + |-1 + 2| = 4

Function Description
Complete the function:
    long long findInterestingPairs(const vector<int>& arr, int sumVal);

Parameters:
- arr[n]: array of integers
- sumVal: integer

Returns:
- A single integer/long long: the number of interesting pairs.

Constraints:
- 1 ≤ n ≤ 1e5
- -1e6 ≤ arr[i] ≤ 1e6
- 1 ≤ sumVal ≤ 1e6

Input Format (for custom testing):
n
arr[0]
arr[1]
...
arr[n-1]
sumVal

Output Format:
A single integer: the count of interesting pairs.

Sample Input 0:
4
1
3
2
0
2

Sample Output 0:
1

Explanation:
Only one interesting pair: (1,4),
since |1 - 0| + |1 + 0| = 1 + 1 = 2.

Sample Input 1:
4
1
4
-1
2
4

Sample Output 1:
2

Explanation:
Pairs (1,4) and (3,4) satisfy the condition (shown above).


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Women Leading

Shakuntala Devi once asked her students sitting in a lecture room to analyze seating rows.
For each row (a string consisting only of 'W' for Women and 'M' for Men), determine the
maximum length of a contiguous block that consists of k consecutive 'W' followed immediately
by k consecutive 'M' (for some k ≥ 1). In other words, find the longest substring of the
form W^k M^k and report its length (which is 2k). If no such substring exists, print -1.

Input Format
- The first line contains an integer R — the number of rows.
- Each of the next R lines contains a string S made up of only 'W' and 'M'.

Output Format
- For each row, print a single integer: the maximum length of a substring of the form
  W^k M^k (k ≥ 1); print -1 if it is not possible.

Constraints
- 1 ≤ R ≤ 10
- 1 ≤ |S| ≤ 10^5

Sample Input
2
WWMMMWMWMMMMMWWWWWWWWMMW
MMMWW

Sample Output
6
-1

Explanation
Row 1: The longest contiguous block of Women followed by Men with equal counts is "WWWMMM",
so the length is 6.
Row 2: There is no substring of the form W^k M^k, hence -1.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Maximum Partition

You are given an array A of N integers (1-based indexing). You may split the array into any number K (K ≥ 1) of
contiguous partitions so that together they cover the whole array in order.

If the partition sums are P1, P2, …, PK, define the “special sum” of the partitioning as:
    P1 − P2 + P3 − P4 + … + (−1)^(K−1) · PK
(i.e., start with +, then alternate −, +, −, …).

Task
Choose a partitioning that maximizes the special sum and output that maximum value.

Notes
• Partitions must be contiguous and in order (no reordering of elements).
• 1-based indexing is assumed in any explanation.

Input Format
• The first line contains an integer N.
• The second line contains N space-separated integers A1, A2, …, AN.

Output Format
• Print a single integer: the maximum achievable special sum.

Constraints
• 1 ≤ N ≤ 10^5
• −10^5 ≤ Ai ≤ 10^6  for all i in [1, N]

Example
Input
5
-1 -2 3 2 9

Output
9

Explanation
One optimal partitioning is: [−1] | [−2, 3] | [2, 9]
Here, P1 = −1, P2 = (−2 + 3) = 1, P3 = (2 + 9) = 11
Special sum = P1 − P2 + P3 = (−1) − 1 + 11 = 9

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Interleaving Subsequences Count

Given three lowercase strings p, q, and r (length ≤ 100), count the number of ways to form
exactly the string r by interleaving a subsequence of p and a subsequence of q, while
preserving the relative order of characters taken from each string. You must use at least
one character from p and at least one character from q. Return the answer modulo 1,000,000,007.

Notes
- “Subsequence” means you may skip characters but cannot reorder them.
- The two chosen subsequences (one from p, one from q) are interleaved to form r.
- At least one character must be taken from each of p and q.

Input Format
- Line 1: string p
- Line 2: string q
- Line 3: string r

Output Format
- A single integer: the number of valid interleavings modulo 1,000,000,007.

Constraints
- 1 ≤ |p|, |q|, |r| ≤ 100
- All strings consist only of lowercase English letters.

Sample
p: ab
q: ba
r: aba

Output:
2

Explanation:
Two valid ways to form "aba":
1) take "a" from p, then "ba" from q
2) take "ab" from p, then "a" from q


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Maximize Subarray-Sum × Pivot Value

Given an array arr of length n, find the maximum possible value of:
    ( sum(arr[i..j]) ) × arr[k]
over all choices of indices i, j, k such that 0 ≤ i ≤ k ≤ j < n.

Input Format
- Line 1: integer n
- Line 2: n space-separated integers arr[0], arr[1], …, arr[n-1]

Output Format
- Print a single integer: the maximum value of (sum of a subarray) multiplied by
  the value at some index k that lies inside that subarray.
  Use 64-bit arithmetic for safety.

Constraints
- 1 ≤ n ≤ 5 × 10^5
- −10^6 ≤ arr[i] ≤ 10^6

Example
Input
5
2 -1 3 -2 4
Output
16

Explanation
Best is to choose subarray [0..4] with sum 6 and k = 4 (arr[k] = 4):
6 × 4 = 24; but even better is subarray [2..4] with sum 5 and k = 4: 5 × 4 = 20.
(Your result should be the maximum over all valid (i, j, k); values can be negative too.)


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem — Minimize Spread After 4-Way Split

You are given an integer N and an array X of N integers (X1 … XN).
Place exactly three cut positions to split X into four **non-empty, contiguous**
subarrays. Let A, B, C, and D be the sums of those four parts (in order).

Your task is to output the **minimum possible value** of:
    max(A, B, C, D) − min(A, B, C, D)

Input Format
• N
• X1 X2 … XN

Output Format
• A single integer: the minimum possible value of max(A,B,C,D) − min(A,B,C,D).

Constraints
• 4 ≤ N ≤ 2⋅10^5
• 0 ≤ Xi ≤ 10^9

Sample 1
Input
5
4 3 5 2 3
Output
2
Explanation
Split as (4) | (3) | (5) | (2,3) → A=4, B=3, C=5, D=5 → 5 − 3 = 2.

Sample 2
Input
7
3 2 1 11 12 5 9
Output
7

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem — Max Equalizable Count with ±1 Operations

You are given an array A of N integers.

For each element Ai you may perform exactly one of the following:
• Add 1 to Ai
• Subtract 1 from Ai
• Do nothing to Ai

After applying these choices to all elements, you may choose any integer K.
Count how many elements are equal to K. Your task is to find the **maximum**
possible count.

Input Format
• The first line contains a single integer N.
• The second line contains N integers: A1 A2 … AN.

Constraints
• 1 ≤ N ≤ 100000
• 0 ≤ Ai ≤ 100000

Output Format
• Print a single integer — the maximum possible number of elements that can be made equal to some K.

Sample
Input
7
3 1 4 1 5 9 2
Output
4
Explanation
Choose K = 2. Values originally equal to 1, 2, or 3 can be turned into 2.
There are 2 (ones) + 1 (two) + 1 (three) = 4 such elements.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Playlist Fun Maximization

You have n songs. The i-th song has:
  - singer[i]: an integer ID of its singer
  - length[i]: its duration (positive integer)

You may reorder the songs arbitrarily. While listening, the fun gained from the
t-th played song equals:
    (# of distinct singers heard among the first t songs) × length of that song.

Goal:
Choose an order that maximizes the total fun
    sum_{t=1..n} (distinct_singers_so_far) * length[ song_at_position_t ],
and return that maximum value.

Constraints
1 ≤ n ≤ 10^5
1 ≤ singer[i] ≤ 10^9
1 ≤ length[i] ≤ 10^9

Example 1
n = 3
singer = [1, 2, 2]
length = [2, 3, 2]
Optimal order: first song (1,2), third song (2,2), second song (2,3)
Fun: 1*2 + 2*2 + 2*3 = 2 + 4 + 6 = 12
Answer: 12

Example 2
n = 3
singer = [1, 1, 2]
length = [5, 4, 3]
Optimal order: second song (1,4), third song (2,3), first song (1,5)
Fun: 1*4 + 2*3 + 2*5 = 4 + 6 + 10 = 20
Answer: 20


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Arranging Numbers (Beautiful Arrangement)

Jayme has the numbers 1..n. A permutation a[1..n] (1-based) is called
“beautiful” if for every position i (1 ≤ i ≤ n) at least one holds:
  - a[i] is divisible by i, OR
  - i is divisible by a[i].
(i.e., a[i] % i == 0 or i % a[i] == 0)

Task:
Count how many beautiful permutations of {1, 2, …, n} exist and return that count.

Input
- A single integer n

Output
- A single integer: the number of beautiful arrangements

Constraints
- 1 < n < 20

Example
Input:
2
Output:
2
Explanation:
Permutations [1,2] and [2,1] both satisfy the divisibility condition at each position.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Element Swapping

Given an array arr of n integers, you may perform the following operation any number of times:
1) Choose an index i (0 ≤ i < n − 1) and swap arr[i] and arr[i + 1].
2) Each element can be swapped at most once during the whole process (i.e., no element participates in more than one swap).

The strength of index i is defined as arr[i] × (i + 1), using 0-based indexing.

Goal:
Find the maximum possible value of
    S = Σ_{i=0}^{n−1} arr[i] × (i + 1)
after applying allowed swaps optimally. Return this maximum.

Example
n = 4
arr = [2, 1, 4, 3]

Optimal swaps:
- swap(arr[2], arr[3])
- swap(arr[0], arr[1])

Final array: [1, 2, 3, 4]
Sum of strengths: 1×1 + 2×2 + 3×3 + 4×4 = 30
Return 30.

Function Description
Complete the function getMaximumSumOfStrengths with the parameter:
    int arr[n]: the initial array
Returns:
    long int: the maximum possible sum of strengths of all indices after optimal swaps.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Maximum Number of Servers Within Budget

Problem Statement
You are given two 0-indexed integer arrays of equal length: bootCost and runCost.
There are n servers in a line. If you run a consecutive group of k servers from
index l to r (k = r - l + 1), the total cost is:

  total_cost(l, r) = max(bootCost[l..r]) + k * sum(runCost[l..r]) + overhead * (k - 1)

where:
- max(bootCost[l..r]) is the largest activation cost in the window [l..r],
- sum(runCost[l..r]) is the sum of running costs in that window,
- overhead is a fixed non-negative integer penalty paid per additional server
  beyond the first in the block (so there are k-1 such links).

You are also given an integer budget.
Return the maximum number k of consecutive servers you can run such that the total
cost does not exceed budget. If no window is affordable, return 0.

Input Format
- Line 1: n
- Line 2: n integers — bootCost[0], bootCost[1], ..., bootCost[n-1]
- Line 3: n integers — runCost[0], runCost[1], ..., runCost[n-1]
- Line 4: two integers — budget and overhead

Output Format
- One integer: the maximum k (length of a contiguous block) that fits within the budget.

Example
Input
5
3 6 1 3 4
2 1 3 4 5
30 1

Output
3


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Challenge: Longest Symmetric Substring with Replacements

Definition
A string is called symmetric if its length is even, the first half consists only of '<'
characters, and the second half consists only of '>' characters.
Examples of symmetric strings: "" (empty string), "<>", "<<>>", "<<<>>>", ...

Task
Given a string S consisting of the characters '<', '>' and/or '?', you may replace each
'?' with either '<' or '>' (independently). Return the length of the longest **contiguous**
substring of S that can be made symmetric after such replacements.

Function signature
int solution(string &S);

Examples
1) S = "<><??>>"
   After replacing all '?' with '<', we get "<<<<<<>". The longest symmetric substring is "<<>>",
   so the function should return 4.

2) S = "??????"
   Replace the first three '?' with '<' and the next three with '>' -> "<<<>>>".
   The function should return 6.

3) S = "<<"
   The function should return 2.

Notes
- |S| is in the range [1 .. 200,000].
- S contains only the characters '<', '>' and '?'.
- Aim for an efficient algorithm.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Lucky Triples

You are given an array a[1..n] of positive integers. Count the number of index triples (i, j, k) such that
  1 ≤ i < j < k ≤ n,
  a[i] divides a[j], and
  a[j] divides a[k].

Print the total number of such triples.

Input
- The first line contains an integer n (1 ≤ n ≤ 2⋅10^5).
- The second line contains n integers a1, a2, …, an (1 ≤ ai ≤ 10^6).

Output
- Print a single integer: the number of triples (i, j, k) with i < j < k, a[i] | a[j], and a[j] | a[k].

Notes
- Use 64-bit integer type for the answer (e.g., long long in C++), as the count can be large.
- Values can repeat; equal values are allowed.

Example 1
Input
4
1 2 2 4

Output
4

Explanation
Valid triples (1-based indices): (1,2,3), (1,2,4), (1,3,4), (2,3,4).

Example 2
Input
6
1 2 3 4 6 12

Output
10

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

C. Maximum Median

You are given an array a of n integers, where n is odd. You can perform the following operation:

- Choose one element of the array (say ai) and increase it by 1 (replace ai with ai + 1).

You want to make the median of the array as large as possible using at most k operations.

Definition:
The median of an odd-sized array is the middle element after the array is sorted in non-decreasing order.
Example: the median of [1, 5, 2, 3, 5] is 3.

Input
The first line contains two integers n and k (1 ≤ n ≤ 2⋅10^5, n is odd, 1 ≤ k ≤ 10^9).
The second line contains n integers a1, a2, …, an (1 ≤ ai ≤ 10^9).

Output
Print a single integer — the maximum possible median after at most k operations.

Examples

Input
3 2
1 3 5
Output
5

Input
5 5
1 2 1 1 1
Output
3

Input
7 7
4 1 2 4 3 4 4
Output
5

Note
- In the first example, you can increase the second element twice to get [1, 5, 5]; median is 5.
- In the second example, increasing the second, third, and fifth elements appropriately yields a median of 3.
- In the third example, increasing the first, fourth, sixth, and seventh elements yields a median of 5.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Time limit: 1.00 s
Memory limit: 512 MB

Problem — Josephus (k-step elimination)

There are n children (numbered 1..n) standing in a circle. Repeatedly, k children are skipped and then the next child is removed from the circle. Determine the order in which the children are removed.

Input
The only input line has two integers n and k.

Output
Print n integers: the removal order.

Constraints
1 ≤ n ≤ 2 · 10^5
0 ≤ k ≤ 10^9

Example
Input:
7 2

Output:
3 6 2 7 5 1 4


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Minimum Total Idle Time (Servers → Tasks)

You have N servers. Each server i takes A[i] time to finish its process.

You must create tasks that use increasing numbers of servers exactly once:
Task 1 uses 1 server
Task 2 uses 2 servers
Task 3 uses 3 servers
…
Task K uses K servers

All servers must be used exactly once. Therefore, N must be a triangular number:
N = 1 + 2 + … + K = K*(K+1)/2
(If no such K exists, output -1.)

For any task (i.e., any chosen group of servers), its idle time is:
idle(group) = max(time in group) − min(time in group)

Goal:
Partition the N servers into K groups of sizes 1,2,…,K so that the sum of idle times
over all groups is minimized. Return that minimum total idle time.

Input:
T                       // number of test cases
For each test case:
  N                     // number of servers
  A1 A2 … AN            // times of the N servers

Output:
For each test case, print a single integer: the minimum possible sum of idle times
(OR -1 if it is impossible to form groups of sizes 1..K that use all servers).

Constraints:
1 ≤ T ≤ 10
1 ≤ N ≤ 1000
1 ≤ A[i] ≤ 10^9
Sum of N over all test cases ≤ 2000

Sample Input:
1
6
1 2 2 2 3 3

Sample Output:
4

Explanation (one optimal partition when N=6 = 1+2+3):
Group sizes: 1 | 2 | 3
Choose (2) | (2,2) | (1,3,3)
Idle times: 0  +  0   +  (3−1)=2  → total 2
Another optimal partition yields total 4 overall minimum across valid partitions is 4.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Compatible Warehouse Pairs in a Weighted Tree

You are given a weighted, undirected tree of N warehouses (nodes), rooted at node 1.
Each edge (u, v) has a positive distance w. For every node v (1-based), you are also given
an integer val[v].

Define distance(u, v) as the sum of edge weights on the unique path between u and v.

A pair (u, v) is called compatible if:
  • u is an ancestor of v in the rooted tree (u lies on the path from 1 to v, u ≠ v), and
  • distance(u, v) ≤ val[v].

Task:
Count the total number of compatible pairs (u, v).

Input Format:
  N
  (N-1) lines follow: u v w      // 1 ≤ u, v ≤ N, edge weight w > 0
  final line: val1 val2 ... valN // values for nodes 1..N

Output Format:
  Print a single integer — the number of compatible pairs.

Notes:
  • The tree is rooted at node 1.
  • Edges are undirected; weights are positive.
  • All node indices are 1-based.

Example
Input:
6
1 6 4
6 5 1
1 2 3
1 4 2
4 3 1
2 1 3 1 5 4

Output:
5

Explanation:
Compatible pairs are:
(1, 6): distance(1,6)=4 ≤ val[6]=4
(1, 5): distance(1,5)=4+1=5 ≤ val[5]=5
(6, 5): distance(6,5)=1 ≤ val[5]=5
(4, 3): distance(4,3)=1 ≤ val[3]=3
(1, 3): distance(1,3)=2+1=3 ≤ val[3]=3
Total = 5.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Title: One-Block Partitions

You are given a binary array Arr of length N (elements are only 0 or 1).

Definition:
A “One block” is a continuous subarray that contains exactly one element equal to 1.

Task:
Partition the entire array Arr into contiguous blocks so that every block is a One block.
Return the total number of different valid partitions. If it is impossible, return 0.

Notes:
- Blocks must cover the whole array without overlap.
- Two partitions are different if they place at least one cut in a different position.

Input
- N : integer, the size of the array (1 ≤ N ≤ 100)
- Arr : N space-separated integers (each 0 or 1)

Output
- A single integer: the number of ways to divide the array into One blocks.

Example 1
Input
3
0 1 0
Output
1
Explanation
The only valid partition is the whole array [0,1,0], which contains exactly one ‘1’.

Example 2
Input
6
1 0 0 1 0 1
Output
6
Explanation
Ones at positions 1,4,6. Zeros between consecutive ones are 2 and 1, so ways = (2+1)*(1+1) = 6.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Title: Unpurchased Categories

There are n items on a website, indexed 0..n-1. The category id of item i is
category[i] (an integer). There are m customers. Customer j buys every item
from index l to r inclusive, given as purchase[j] = [l, r].

Task
Return all DISTINCT category ids for which **no item of that category was ever
purchased by any customer**. Sort the result in ascending order. If every
category had at least one item purchased, return [-1].

Function
vector<int> getUnpurchasedCategories(vector<int> category,
                                     vector<vector<int>> purchase)

Input (custom testing)
n
category[0]
category[1]
...
category[n-1]
m
purchase[0][0] purchase[0][1]
purchase[1][0] purchase[1][1]
...
purchase[m-1][0] purchase[m-1][1]

Output
A line with the desired category ids in ascending order (or -1 if none).

Constraints
1 ≤ n ≤ 1e5
1 ≤ category[i] ≤ 1e9
0 ≤ m ≤ 1e5
0 ≤ purchase[j][0] ≤ purchase[j][1] < n

Example
n = 5
category = [1, 2, 5, 4, 5]
m = 3
purchase = [[0, 1], [0, 2], [1, 2]]

Items purchased cover indices {0,1,2}; thus categories purchased are {1,2,5}.
Category 4 never appears among purchased indices → answer: [4].

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Title: Assign Requests to Least-Loaded Servers

You have N servers labeled 1..N. Initially, each server’s total load is 0.
There are M incoming requests; the i-th request has load requests[i].

Assignment rule for each request (in order):
1) Choose the server with the smallest current total load.
2) If multiple servers tie, choose the one with the smallest label.
3) Assign the request to that server and increase that server’s load by the request’s load.

Task
Return an array of length M where the i-th element is the label of the server that handles the i-th request.

Input (for custom testing)
N
M
requests[0] requests[1] ... requests[M-1]

Output
M lines, each with the label (1..N) of the server that handled the corresponding request.

Constraints
1 ≤ N ≤ 2 * 10^5
1 ≤ M ≤ 2 * 10^5
0 ≤ requests[i] ≤ 10^9

Notes / Hint
Use a min-heap (priority queue) of (current_load, label) to always pop the least-loaded server; this
automatically breaks ties by smallest label.

Example
Input
2
2
5 5
Output
1
2
Explanation:
Start loads: (0,#1), (0,#2). First request -> #1 (tie broken by smallest label).
Loads become (5,#1), (0,#2). Second request -> #2. Final assignment sequence: [1, 2].


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem Statement:
You are given an integer array arr of length n.
You can perform the following operation exactly k times:

1. Choose any index i (0 ≤ i < n) and add arr[i] to your total score.
2. After choosing i, discard either all elements to the left of i (arr[0..i−1])
   or all elements to the right of i (arr[i+1..n−1]).
   The remaining part becomes the new array for the next operation.

Your task is to maximize the total score after exactly k operations.

Example:
Input:
n = 6
arr = [4, 6, -10, -1, 10, -20]
k = 4

Process:
1. Choose arr[4] = 10 → keep left → arr = [4, 6, -10, -1], score = 10
2. Choose arr[0] = 4 → keep right → arr = [6, -10, -1], score = 14
3. Choose arr[0] = 6 → keep right → arr = [-10, -1], score = 20
4. Choose arr[1] = -1 → keep right → arr = [ ], score = 19

Output:
19

Explanation:
Each time you pick an element, you can only continue from one side.
However, any subset of k elements can be picked if you always choose
from the extremes of your target indices.
Therefore, the maximum total score equals the sum of the k largest
elements in the array.

Constraints:
1 ≤ n ≤ 10⁵
−10⁹ ≤ arr[i] ≤ 10⁹
1 ≤ k ≤ n


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem — Count Beautiful Subarrays

You are given an array A of length n (0-indexed). A subarray is called “beautiful” if:
• Its length is odd (always beautiful), OR
• Its length is even and the two middle elements are equal.

Formally, for a subarray A[l..r] with length L = r − l + 1:
• If L is odd → beautiful.
• If L is even → beautiful iff A[l + L/2 − 1] == A[l + L/2].

Your task is to count the total number of beautiful subarrays of A.

Input
• n — the length of the array (1 ≤ n ≤ 2⋅10^5)
• A1, A2, …, An — the array elements (1 ≤ Ai ≤ 10)

Output
• A single integer: the number of beautiful subarrays.

Example
Input:
5
3 1 2 2 4

Output:
11

Explanation (informal):
All odd-length subarrays are beautiful. Among even-length subarrays, only those whose two middle elements are equal are counted (e.g., [1,2,2,4] has middle elements 2 and 2).



XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Minimum Shifts

Given an n×m binary matrix mat (provided as an array of strings of length m),
you may perform row operations. In one operation you can cyclically shift a single
row by 1 position either to the left or to the right (wrapping around). Each 1-step
shift counts as cost 1.

Task:
Find the minimum total number of shifts needed so that there exists at least one
column whose cells are all '1'. If it is impossible, return -1.

Notes:
• mat[i] is the i-th row; all rows have equal length m.
• A cyclic left shift moves each character one position left and the first character
  goes to the end. A cyclic right shift moves each character one position right and
  the last character goes to the front.

Function to implement:
int findMinimumShifts(vector<string> mat);

Return:
An integer — the minimum number of shifts required to make at least one column
all '1', or -1 if not possible.

Constraints:
1 ≤ n ≤ 10000
1 ≤ m ≤ 1000
Each mat[i] consists only of characters '0' and '1'.

Input format (for custom testing):
Line 1: n
Next n lines: each line is a binary string of length m describing a row of the matrix.

Output (for custom testing):
Single integer — the answer.

Example 1:
Input
4
0101
1010
0100
0001
Output
3
Explanation
Rotate row 1 right (0101→1010), row 3 right (0100→0010), row 4 left (0001→0010).
Then column 3 becomes all '1'. Total shifts = 3.

Example 2:
Input
3
111
101
000
Output
-1
Explanation
The third row is all zeros, so no column can be made all '1'.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Question: finalPrice — Shopkeeper Sale

A shopkeeper arranges items in a list for a sale. From left to right, each
item i is sold at its full price price[i] minus the price of the first item
to its right with a price that is less than or equal to price[i]. If no such
item exists, item i is sold at full price.

Given an integer array prices, compute:
  1) The total cost (sum of all final prices).
  2) The 0-based indices of the items that are sold at full price
     (i.e., no discount applied), in ascending index order.

Print the results as:
  <total_cost>
  <index1 index2 ...>

Constraints
- 1 ≤ n ≤ 100000
- 1 ≤ prices[i] ≤ 1000000

Example
prices = [2, 3, 1, 2, 4, 2]
Final prices = [1, 2, 1, 0, 2, 2]
Total cost = 8
Full-price indices = 2 5
Output:
8
2 5

Sample 0
n = 6
prices = [5, 1, 3, 4, 6, 2]
Output:
14
1 5

Sample 1
n = 5
prices = [1, 3, 3, 2, 5]
Output:
9
0 3 4


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Question: countBalancedNumbers — Balanced Numbers in a Permutation

You are given a permutation p of length n (i.e., it contains each integer
from 1 to n exactly once in any order).

A number k (1 ≤ k ≤ n) is called balanced if there exist indices l and r
(1 ≤ l ≤ r ≤ n) such that the subarray p[l], p[l+1], …, p[r] is a permutation
of the numbers {1, 2, …, k}. In other words, within some contiguous segment
of p you can find all numbers 1..k exactly once.

For each k from 1 to n, determine whether k is balanced. Return a binary
string of length n where the i-th character is ‘1’ if i is balanced and ‘0’
otherwise.

Input
- First line: integer n
- Second line: n integers — the permutation p1 … pn

Output
- A single line containing the binary string described above.

Constraints
- 1 ≤ n ≤ 2 × 10^5
- 1 ≤ p[i] ≤ n
- All p[i] are distinct.

Example
n = 4
p = [4, 1, 3, 2]
Balanced numbers are 1, 3, and 4 (but not 2), so the output is:
1011

Sample 0
Input:
5
5 3 1 2 4
Output:
11111

Sample 1
Input:
4
1 4 2 3
Output:
1001


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem Summary
You have N robots in a line, each with:

Health (positive integer)
Direction (0 = left, 1 = right)

Rules

Robots move simultaneously in their directions
When two robots collide (moving towards each other):

The robot with less health is knocked out
The robot with more health continues with health reduced by opponent's health
If same health, both are knocked out


Robots never change direction

Input

N: number of robots
A: 2D array of size N×2

A[i][0] = health of robot i
A[i][1] = direction of robot i (0=left, 1=right)



Output
Return a 2D array with [health, direction] of surviving robots in their original order (1 to N).
Example
Input:

N = 4
A = [[39, 1], [20, 0], [21, 0], [12, 0]]

Output:

[[2, 0], [12, 0]]

Explanation:

Robot 1 (health 39, right) collides with Robot 2 (health 20, left) → Robot 1 survives with 19 health
Robot 1 (health 19, right) collides with Robot 3 (health 21, left) → Robot 3 survives with 2 health
Robot 3 (health 2, left) and Robot 4 (health 12, left) both move left, never collide
Final survivors: Robot 3 [2, 0] and Robot 4 [12, 0]


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Amazon has N packages lined up for delivery.
The weight of the i-th package is given by arr[i].

A delivery team wants to analyze performance by checking
continuous groups of packages where the average package
weight is greater than or equal to K.

Your task is to find the number of such continuous subarrays
that satisfy this condition.

Example:
N = 5, K = 4
arr = [3, 4, 5, 6, 2]

Output: 12

The continuous groups of packages with average weight >= 4
are: [3,4,5], [4,5], [4,5,6], [5,6], [6], [3,4,5,6], [4,5,6,2], [3,4,5,6,2].

Constraints:
1 ≤ N ≤ 100000
1 ≤ arr[i], K ≤ 10^9

Input Format:
The first line contains two integers N and K — the number of
packages and the threshold average weight.

The second line contains N integers representing the weights
of the packages.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Quiz Competition

A class has students with various talents, each represented by an integer from 1 to talentsCount. 
You need to form teams for a quiz competition, where each team must have at least one member with 
each talent.

Teams must be formed from consecutive students in the array. For each possible starting position, 
determine the minimum number of students needed to form a valid team. If it is not possible to form 
a team with all talents from a particular starting position, return -1 for that position.

Example:
talentsCount = 3
talent = [1, 2, 3, 2, 1]

- Starting at position 1: [1, 2, 3] includes all talents, minimum size = 3
- Starting at position 2: [2, 3, 2, 1] is the smallest subarray with all talents, minimum size = 4
- Starting at position 3: [3, 2, 1] includes all talents, minimum size = 3
- Starting at positions 4 and 5: Cannot form a team with all talents, return -1

The result is [3, 4, 3, -1, -1].

Function Description:
Complete the function teamSize in the editor with the following parameter(s):
- int talent[n]: the students' talents
- int talentsCount: the number of talents represented numbered from 1 to talentsCount

Returns:
- int[n]: at each index, the minimum size subarray required, or -1 if an appropriate subarray does not exist

Constraints:
- 1 ≤ n, talentsCount ≤ 10^5
- 1 ≤ talent[i] ≤ talentsCount

Sample Input:
n = 8
talent = [1, 1, 2, 2, 3, 1, 3, 2]
talentsCount = 3

Sample Output:
5
4
4
3
4
3
-1
-1

Explanation:
The shortest subarrays for each position:
Beginning at the first position: [1, 1, 2, 2, 3] (length 5)
Second position: [1, 2, 2, 3] (length 4)
Third position: [2, 2, 3, 1] (length 4)
Fourth position: [2, 3, 1] (length 3)
Fifth position: [3, 1, 3, 2] (length 4)
Sixth position: [1, 3, 2] (length 3)

No further subarrays will have 3 elements.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Connect the Country 2

There are n cities in a country, each with an associated cost given in an array called cost. 
The cost to build a bidirectional road between two cities i and j is the sum of their respective 
costs, cost[i] + cost[j]. Additionally, there are m offers available, each defined by a triplet 
[i, j, k], meaning a road can be built between cities i and j for a cost of k.

You can choose to either use an offer or pay the sum of the costs to build a road between two cities. 
The goal is to determine the minimum cost required to ensure all cities are interconnected, meaning 
there is a path between every pair of cities.

Example:
n = 5
m = 2
cost = [3, 1, 2, 3, 1]
offers = [[3, 4, 1], [1, 5, 6]]

Optimally, you can build the roads as follows:
- Build a road between cities 3 and 2, and pay the cost of cost[3] + cost[2] = 2+1 = 3 units.
- Build a road between cities 3 and 4, and use the first offer to pay the cost of 1 unit.
- Build a road between cities 5 and 1, and pay the cost of cost[5] + cost[1] = 1+3 = 4 units.
- Build a road between the cities 2 and 5, and pay the cost of cost[2] + cost[5] = 1+1 = 2 units.

So, the total cost = 3 + 1 + 4 + 2 = 10.

Function Description:
Complete the function minimumCost in the editor with the following parameters:
- int costs[n]: the cost associated with each city
- int offers[m][3]: the offers available

Returns:
- int: the minimum cost required to connect all the cities

Constraints:
- 2 ≤ n ≤ 10^5
- 1 ≤ m ≤ 10^5
- 1 ≤ cost[i] ≤ 10^4
- 1 ≤ offer[i][0], offer[i][1] ≤ n, offer[i][0] ≠ offer[i][1]
- 1 ≤ offer[i][2] ≤ 10^4

Sample Input:
n = 3
cost = [1, 2, 1]
m = 3
offers = [[1, 3, 4], [1, 2, 4], [3, 2, 1]]

Sample Output:
3

Explanation:
Optimally, build the roads as follows:
- Build a road between cities 3 and 1, and pay the cost of cost[3] + cost[1] = 1+1 = 2 units.
- Build a road between cities 3 and 2, and use the third offer to pay the cost of 1 unit.

So, the total cost = 2 + 1 = 3.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Code Question 1 - Amazon Subscription Model

Amazon is designing a new subscription model for its cloud services. 
The company offers n types of base plans, with their respective costs 
stored in an array planCost, and m types of additional features, each 
with its own cost stored in an array featureCost.

Customers can select one base plan and one additional feature. The 
total subscription cost is the sum of the base plan's cost and the 
feature's cost.

However, there are X specific combinations of base plans and features 
that are not allowed due to technical restrictions. These incompatible 
combinations are represented by two arrays, incompatiblePlans and 
incompatibleFeatures, where incompatiblePlans[i] and incompatibleFeatures[i] 
represent the base plan and the additional feature that cannot be paired 
together (in 1-based indexing).

Out of all possible valid combinations of a base plan and an additional 
feature, the task is to find the maximum cost of any valid combination.

Note: The constraints guarantee that there will always be at least one 
valid combination available.

Example:
n = 2
m = 2
X = 1
planCost = [5, 10]
featureCost = [2, 6]
incompatiblePlans = [1]
incompatibleFeatures = [2]

Exploring all the possible valid combinations of a base plan and an 
additional feature (1-based indexing):

| Base Plan | Additional | Is          | Total         |
| Index-(i) | Feature    | Combination | Subscription  |
|           | Index-(j)  | Valid?      | Cost          |
|-----------|------------|-------------|---------------|
| 1         | 1          | Yes         | 5 + 2 = 7     |
| 1         | 2          | No          | -             |
| 2         | 1          | Yes         | 10 + 2 = 12   |
| 2         | 2          | Yes         | 10 + 6 = 16   |

Out of all the possible valid combinations, the maximum subscription 
cost possible is 16.

Another Example:
n = 3
m = 2
X = 2
planCost = [2, 1, 5]
featureCost = [1, 6]
incompatiblePlans = [1, 2]
incompatibleFeatures = [1, 2]

Sample Output: 7

Explanation:
Exploring all the possible valid combinations of a base plan and an 
additional feature (1-based indexing):

| Base Plan | Additional | Is          | Total         |
| Index-(i) | Feature    | Combination | Subscription  |
|           | Index-(j)  | Valid?      | Cost          |
|-----------|------------|-------------|---------------|
| 1         | 1          | No          | -             |
| 1         | 2          | Yes         | 2 + 6 = 8     |
| 2         | 1          | Yes         | 1 + 1 = 2     |
| 2         | 2          | No          | -             |
| 3         | 1          | Yes         | 5 + 1 = 6     |
| 3         | 2          | No          | -             |

Out of all the possible valid combinations, the maximum subscription 
cost possible is 7.
Hence, the answer is 7.

Function Description:
Complete the function getMaximumCost in the editor below.

Function Parameters:
- int planCost[n]: the base prices of the subscription plans
- int featureCost[m]: the costs of the additional features
- int incompatiblePlans[X]: the indices of the incompatible 
  subscription plans
- int incompatibleFeatures[X]: the indices of the incompatible 
  features

Returns:
- int: the maximum cost of a valid combination

Constraints:
- 2 ≤ n, m ≤ 10^5
- 1 ≤ X ≤ min(2 * 10^5, (n * m) - 1)
- 1 ≤ planCost[i], featureCost[i] ≤ 10^9
- 1 ≤ incompatiblePlans[i] ≤ n
- 1 ≤ incompatibleFeatures[i] ≤ m
- The pair (incompatiblePlans[i], incompatibleFeatures[i]) is unique 
  for every i.
- At least one valid combination always exists.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Code Question 2 - Amazon Data Distribution Algorithm

The developers at Amazon are working on an algorithm for their data 
distribution over regions based on a parameter called affinity defined 
for each data place. There are n (n is even) different data places 
where the affinity parameter of the ith place is represented by 
affinity[i]. The data needs to be distributed over 2 regions, namely 
regionA and regionB. In each step of the algorithm, a region is 
chosen and then a data place is migrated to that region. The same 
region cannot be chosen in consecutive steps. Each time a region is 
selected, it is configured to maximize the total affinity of data it will 
store and decides which data place to choose accordingly.

Moreover, there are certain pre-defined rules for the data distribution 
represented by m unique pairs of indices, the indexes follow 1-based 
indexing in the input, in a matrix rules. For each unique pair (x, y), if 
the data piece present at the indices x or y is selected for a region, 
the other must be selected for the next region in the next step 
mandatorily.

Find the maximum possible sum of memory stored in regionA.

Example:
Given n = 6, affinity = [3, 2, -4, 8, 3, -7], m = 2, rules = [[2, 4], [3, 6]]

| Region | Affinity | Reason |
|--------|----------|--------|
| A      | -4       | Forces regionB to choose -7 because of rule (3, 6) |
| B      | -7       | Forced by rule (3, 6) |
| A      | 8        | Forces regionB to choose 2 because of rule (2, 4) |
| B      | 2        | Forced by rule (2, 4) |
| A      | 3        | Maximum affinity out of the remaining |
| B      | 3        | Last available data piece |

The total affinity of regionA = (-4) + 8 + 3 = 7, which is the maximum 
possible sum of memory stored in regionA.

Sample Case 0:
n = 4
affinity = [1, 2, 3, 4]
m = 1
rules = [[4, 2]]

Sample Output: 7

Explanation:
For the regionA, the indices of the data places are chosen in the 
order [4, 3]. This will force the regionB to choose the data places at 
the indices in the order [2, 1].
The maximum possible affinity for regionA is 4 + 3 = 7.

Sample Case 1:
n = 6
affinity = [1, 2, 3, 4, 5, 6]
m = 3
rules = [[4, 2], [3, 4], [5, 6]]

Sample Output: 12

Explanation:
For the regionA, the indices of the data places are chosen in the 
order [6, 4, 2]. This will force the regionB to choose the data places at 
the indices in the order [5, 3, 1].
The maximum possible affinity for regionA is 6 + 4 + 2 = 12.

Function Description:
Complete the function maximumAffinity in the editor below.
maximumAffinity has the following parameters:
- int affinity[n]: the affinity parameter for different data places
- int rules[m][2]: the different pair of indices, rules[i][0] and rules[i][1] 
  denote the i-th unique pair.

Returns:
- long int: the maximum possible affinity for regionA.

Constraints:
- 2 ≤ n ≤ 10^5, n is even.
- -10^9 ≤ affinity[i] ≤ 10^9
- 1 ≤ m ≤ n/2
- 1 ≤ rules[i][j] ≤ N
- All the values in rules are distinct.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

🚖 Uber SDE-1 Interview Question: Median in Prefix Subarrays
Problem Context
Uber’s data analytics team is studying the dynamic stability of their driver ratings system.
 Each driver receives a unique rating (a permutation of integers from 1 to n), representing the relative performance among n drivers.
The team wants to analyze how the set of possible median ratings evolves as new drivers join one by one.

Task
You are given a permutation p of size n, where p[i] represents the rating of the i-th driver joining the system.
For each prefix of this permutation (i.e., first i drivers), determine f(i) — the count of distinct ratings among the first i drivers that can act as a median of at least one subarray completely contained within that prefix.
Formally, for each i (1 ≤ i ≤ n):
f(i) = number of distinct elements x in p[1...i] such that x is the median of some subarray of p[1...i] and size of subarray>=2 
You must output all f(1), f(2), ..., f(n).
Median Definition
For a subarray of size m:
If m is odd, the median is the element at position (m + 1) / 2 after sorting.
If m is even, the median is the element at position m / 2 after sorting (i.e., the lower median)
Example
Input:
5
3 1 4 5 2

Output:

0 1 2 3 

Constraints
1 ≤ n ≤ 2 × 10^5

1 ≤ p[i] ≤ n

p is a permutation of integers 1...n

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem: Minimum Operations to Sort by Zeroing Values

You are given an array a of length n.
You may perform the following operation any number of times:

Operation:
- Choose any integer x.
- For all indices i with a[i] = x, set a[i] = 0 (all such positions change in one operation).

Goal:
Find the minimum number of operations needed to make the array sorted in non-decreasing order.

Input Format
- The first line contains an integer n — the length of the array.
- The second line contains n integers a1, a2, ..., an — the array elements.

Output Format
- Print a single integer — the minimum number of operations required to make the array non-decreasing.

Constraints
- 1 < n ≤ 10^3
- 1 ≤ ai ≤ n

Sample Input
3
3 3 2

Sample Output
1

Explanation
Choose x = 3. After the operation, the array becomes [0, 0, 2], which is already non-decreasing. Hence, only 1 operation is needed.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem: Time to Remove All "01" Substrings

You are given a binary string s consisting of characters '0' (red) and '1' (blue).
A process runs in discrete seconds. At each second, ALL substrings equal to "01"
that are present in s are simultaneously replaced with "10".
Repeat this each second until there is no "01" left in s.

Task
Return the total number of seconds required for the process to stop.

Input
- A single line containing the binary string s (1 ≤ |s| ≤ 2e5).

Output
- A single integer: the number of seconds until no "01" remains.

Example 1
Input
0101
Output
2
Explanation
t=0: 0101  (two "01" at positions 0 and 2)
t=1: 1010
t=2: 1100  (no "01" → stop)

Example 2
Input
1111
Output
0
Explanation
No "01" exists initially.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

 Question 

For each word in a list, determine the minimum number of character replacements needed so that no two adjacent characters are the same.
If any two adjacent characters in a string are equal, one of them must be changed. Calculate the minimum number of substitutions required for each word.

Example
words = ["add", "boook", "break"]

"add": change one 'd' (1 change)
"boook": change the middle 'o' (1 change)
"break": no changes necessary (0 changes)

The return array is [1, 1, 0].

Function Description
Complete the function minimalOperations in the editor with the following parameter:

string words[n]: an array of strings

Returns
int[n]: each element i is the minimum number of substitutions for words[i].

Constraints
1 ≤ n ≤ 100
2 ≤ length of words[i] ≤ 10^5
Each character of words[i] is in the range ascii[a-z].

--------------------------------
Sample Case 0
--------------------------------

Sample Input 0
5
ab
aab
abb
abab
abaaaba

Sample Output 0
0
1
1
0
1

Explanation 0
words[0] = "ab" is already acceptable, so 0 replacements are needed.
words[1] = "aab" is not acceptable. Replace an 'a' with an appropriate character, so 1 replacement.
words[2] = "abb" is not acceptable. Replace a 'b' with an appropriate character, again 1 replacement.
words[3] = "abab" is already acceptable, so 0 replacements are needed.
words[4] = "abaaaba" is not acceptable. Replace the middle 'a' in "aaa", 1 replacement.

The return array is [0, 1, 1, 0, 1].


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

In one operation on an array of integers:

• Choose any two adjacent elements.
• Insert the sum of the adjacent pair in their place.

Given an array of integers arr[n], perform this operation 0 or more times to create a non-decreasing array. Choose the operations to maximize the length of the resultant sorted array. Return that maximum length.

Example
n = 5
arr = [2, 4, 1, 6, 12]

Using 0-based indexing, choose arr[2] = 1 and arr[3] = 6. Replace the pair with their sum, 1 + 6 = 7, to yield [2, 4, 7, 12]. The array is non-decreasing and contains 4 elements. This is the longest result possible, so return 4.

Function Description
Complete the function optimalSumOperations in the editor below.

optimalSumOperations has the following parameter:
• int arr[n]: the array to sort

Returns
• int: the maximum length array one can obtain

Constraints
• 1 ≤ n ≤ 2 × 10^3
• 1 ≤ arr[i] ≤ 10^9


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Stone Game – stoneDifference

You are given an integer n and an array stones of length n, where stones[i] is the value of the i-th stone.

Two players A and B play a game. A moves first, then they alternate turns.

On each turn, the current player must choose exactly ONE stone to remove from the array, but only from one of the two ends:
- Either remove the leftmost stone, or
- Remove the rightmost stone.

Let S be the sum of the values of all stones that remain AFTER the chosen stone is removed.
The current player’s score for that move increases by S.

The game continues until there are no stones left.

Both players play optimally, each trying to maximize their own final total score.

Your task:
Return the final score difference between A and B, defined as:
    (total score of A) – (total score of B),
assuming both play optimally.

Examples:

Example 1:
Input:
n = 5
stones = [5, 3, 1, 4, 2]

Output:
6

Example 2:
Input:
n = 8
stones = [7, 90, 5, 1, 100, 10, 10, 2]

Output:
122


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

The Dungeon Escape Challenge – findSafeWalk

You are given:
- An m x n binary matrix grid.
- An integer health representing your starting health.

Grid rules:
- grid[i][j] = 0 → safe cell, your health does not change when you step here.
- grid[i][j] = 1 → trap cell, you lose 1 health when you step here.

You start at the top-left cell (0, 0) with initial health.
You want to reach the bottom-right cell (m - 1, n - 1).

Movement rules:
- From a cell (i, j), you may move to one of its 4-directionally adjacent neighbors:
  - Up:    (i - 1, j)
  - Down:  (i + 1, j)
  - Left:  (i, j - 1)
  - Right: (i, j + 1)
- You may not move outside the grid.
- When you step onto a trap cell (value 1), your health decreases by 1.
- Your health must always remain strictly greater than 0.
  - If at any point your health becomes 0 or negative, you die and that path is invalid.

Task:
Among all valid paths from (0, 0) to (m - 1, n - 1) that never let your health be ≤ 0:
- Compute the maximum possible remaining health when you arrive at (m - 1, n - 1).

Return:
- The maximum remaining health at (m - 1, n - 1), if there exists at least one valid path.
- If there is no valid path that keeps you alive, return -1.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Code Question 1 – System Stability Risk

Amazon is launching a resource optimization feature that includes an advanced
diagnostic program to detect potential system vulnerabilities. The framework
manages n active services, each with a unique Service Identifier (SID).

The diagnostic program evaluates the overall system stability using this
algorithm:
  • It analyzes all contiguous subarrays of SIDs represented by the array service_id.
  • For each subarray, it calculates the sum of the SIDs and divides this sum
    by a constant integer modulus.
  • The remainder obtained from this division is compared to the number of
    services (length) in that subarray.
  • A subarray is flagged as vulnerable if:
        (sum of SIDs in the subarray) % modulus == (number of elements in subarray)
  • The overall system stability risk is the total count of such flagged
    contiguous subarrays.

Formally:
  • You are given an array service_id of size n.
  • You are also given an integer modulus.
  • Your task is to compute and return the system's stability risk level, i.e.,
    the number of vulnerable contiguous subarrays.

Notes:
  • Remainder is defined as the remaining part after division.
    For example, the remainder of 13 with 5 is 3.
  • A subarray is a continuous portion of an array, e.g., in [5, 7, 9, 11],
    possible subarrays include [5], [5, 7], [7, 9, 11], [11], etc.

Function Description:
  Complete the function determineStabilityRisk:

      long determineStabilityRisk(vector<int> service_id, int modulus);

  Parameters:
    • service_id: vector<int> of size n, SIDs of the services.
    • modulus: integer used to compute the remainder.

  Returns:
    • long: the overall stability risk of the system (count of vulnerable
      contiguous subarrays).

Constraints:
  • 1 ≤ n ≤ 2 × 10^5
  • 1 ≤ service_id[i] ≤ 10^9
  • 1 ≤ modulus ≤ 10^9

Input format for custom testing (STDIN):
  n
  service_id[0]
  service_id[1]
  ...
  service_id[n-1]
  modulus

Sample Case 0:
  Input:
    5
    1
    4
    2
    3
    5
    100

  Output:
    1

  Explanation:
    There is only one vulnerable subarray: [1].
    sum = 1, length = 1, 1 % 100 = 1 → equals length, so it is flagged.

Sample Case 1:
  Input:
    3
    2
    2
    2
    2

  Output:
    0

  Explanation:
    All subarrays have sum that is a multiple of 2, so remainder is always 0.
    Length is at least 1, so remainder never equals length.
    Hence, no subarray is vulnerable, stability risk = 0.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


You are managing a row of building structures with varying heights represented by an
array `structures`. You want to transform these structures into a harmonious pattern
where each structure differs from its adjacent neighbors by exactly one unit in
height, forming either an ascending or descending sequence.

To modify the structures, you can only add one unit of height to any structure in a
single operation. Your goal is to determine the minimum number of operations needed
to achieve either an ascending or descending stepwise pattern – whichever requires
fewer operations.

Example

• For `structures = [1, 4, 3, 2]`, the output should be `solution(structures) = 4`.

  The optimal approach is to add:
    - Four units to the first structure.

  The final heights will be: `[5, 4, 3, 2]`, forming a descending stepwise pattern.

• For `structures = [5, 7, 9, 4, 11]`, the output should be
  `solution(structures) = 9`.

  The optimal approach is to add;




XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem: Maximum System Memory Capacity

The developers at Amazon are working on optimizing the capacity of their cloud system. In the system, there are n servers where the memory capacity of the i-th server is represented by the array memory[i].

A system configuration always contains an even number of servers. If the system has 2x servers in use, then:
- x of them are chosen as primary servers, and
- the other x are chosen as backup servers.

For each primary server P there must exist a backup server B such that:
    memory[B] ≥ memory[P]

Each server can be used at most once (either as a primary, or as a backup, or not used at all).

The system memory capacity of a configuration is defined as the sum of the memory capacities of all the primary servers.

Given n and the array memory, find the maximum possible system memory capacity that can be obtained by choosing some valid set of primary and backup servers.

Function Description (C++):
    long maximumCapacity(vector<int> memory);

Parameters:
    memory: an integer array, where memory[i] is the memory capacity of the i-th server.

Returns:
    long: the maximum system memory capacity.

Constraints:
    2 ≤ n ≤ 2 * 10^5
    1 ≤ memory[i] ≤ 10^9

Examples:

Example 1:
Input:
    n = 4
    memory = [1, 2, 1, 2]
Output:
    3
Explanation:
    We can choose servers with memory 1 and 2 as primaries,
    and use the remaining 1 and 2 as their backups.
    The primary capacities are 1 and 2, so the total capacity is 3.

Example 2:
Input:
    n = 3
    memory = [1, 2, 1]
Output:
    1
Explanation:
    We can choose the server with memory 1 as primary
    and the server with memory 2 as backup (2 ≥ 1).
    The total capacity is 1. Any configuration with 2 primaries is impossible,
    because there would not be enough backup servers of sufficient capacity.

Example 3:
Input:
    n = 5
    memory = [2, 4, 3, 1, 2]
Possible valid configurations include:
    - Primary: 2, 3; Backup: 4, 2  → capacity = 5
    - Primary: 2, 4; Backup: 3, 2  → capacity = 6 is NOT valid because 3 < 4.
The maximum achievable capacity is 5.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


You need to hire developers for a project that requires exactly N
front-end developers and exactly M back-end developers. There are
(N + M) candidates who applied.

Each candidate can work either on the front-end or on the back-end, 
but not both.

Each candidate has two associated costs:

F[i]: the cost if the candidate works on the front-end
B[i]: the cost if the candidate works on the back-end

Your task is to determine the minimum total cost to assign exactly

N candidates as front-end developers
M candidates as back-end developers

All candidates must be assigned exactly one role (either FE or BE).

Input Format
The first line contains an integer T — the number of test cases.

For each test case:
An integer N — number of front-end developers required.
An integer M — number of back-end developers required.
A list F of length (N + M) — F[i] values.
A list B of length (N + M) — B[i] values.

Output Format
For each test case, print a single integer: the minimum possible
total cost.

Constraints
1 ≤ T ≤ 10
1 ≤ N, M ≤ 10^4
1 ≤ F[i], B[i] ≤ 10^4

Example:
Input:
2
1 1
1 2
2 1
1 2
1 1 1
1 1 1

Output:
2
3

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem Statement

For positive integers x, y, define f(x, y) as follows:

- Write x and y in decimal notation without leading zeros.
- Interpret them as strings and concatenate them in this order to obtain a string S.
- Interpret S as an integer in decimal notation.

For example:
- f(12, 3) = 123
- f(100, 40) = 10040

You are given positive integers N, M and a sequence of N positive integers
A = (A1, A2, …, AN).

Find the number of pairs of integers (i, j) that satisfy all of the following conditions:

1) 1 ≤ i, j ≤ N
2) f(Ai, Aj) is a multiple of M.

Constraints
-----------
1 ≤ N ≤ 2 × 10^5
1 ≤ M ≤ 10^9
1 ≤ Ai ≤ 10^9
All input values are integers.

Input
-----
The input is given from standard input in the following format:

N M
A1 A2 … AN

Output
------
Output the number of pairs of integers (i, j) that satisfy all the conditions.

Sample Input 1
--------------
2 11
2 42

Sample Output 1
---------------
2

Explanation:
(i, j) = (1, 1): f(A1, A1) = 22, which is a multiple of 11.
(i, j) = (1, 2): f(A1, A2) = 242, which is a multiple of 11.
(i, j) = (2, 1): f(A2, A1) = 422, which is not a multiple of 11.
(i, j) = (2, 2): f(A2, A2) = 4242, which is not a multiple of 11.
Thus, the valid pairs are (1, 1) and (1, 2), so the answer is 2.

Sample Input 2
--------------
4 7
2 8 16 183

Sample Output 2
---------------
4

Sample Input 3
--------------
5 5
1000000000 1000000000 1000000000 1000000000 1000000000

Sample Output 3
---------------
25

Sample Input 4
--------------
12 13
80 68 862370 82217 8 56 5 168 672624 6 286057 11864

Sample Output 4
---------------
10

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Software developed these days is subject to frequent cyber attacks.

To prevent the attacks from succeeding, the security team at Amazon ensures the security
of its systems by running tests against n files, where the i-th file has size fileSize[i]
and there are n viruses.

The i-th virus attacks the i-th file and is only effective against a file with size
affinity[i]. To minimize the damage caused, the team performs certain operations.

In one operation, the team can choose 2 files, i and j, and swap their sizes,
i.e., fileSize[i] and fileSize[j].

Given the sizes of files and the viruses' affinities, find the minimum number of
operations performed such that fileSize[i] != affinity[i] for each file from 1 to n.
If it is not possible to do so after any number of operations, return -1.

Example:
Consider the number of files to be n = 5,
fileSize = [2, 2, 1, 1, 2]
affinity = [2, 1, 1, 1, 2]



XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem Description

AWS provides scalable systems. A set of n servers are used for horizontally
scaling an application. The goal is to have the computational power of the
servers in non-decreasing order.

To do so, you can increase the computational power of each server in any
contiguous segment by x (x ≥ 0). You may perform this operation any number of
times on any segments. Choose the values of x for these operations such that,
after all operations, the computational powers are in non-decreasing order and
the sum of all chosen x values is minimum.

Complete the function findMinimumSum in the editor below.



XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

You are given an integer n and an array a of length n.

In one operation, you may choose an index i (0 <= i < n) and do exactly one of the following:
  - Move a[i] to the front of the array (position 0), keeping the relative order of all other elements.
  - Move a[i] to the back of the array (position n-1), keeping the relative order of all other elements.

Each such move counts as one operation.

Your task is to find the minimum number of operations required to make the array sorted in non-decreasing order.

Assume that all elements of the array are distinct
(i.e., the array is a permutation after coordinate compression).

Input
------
The first line contains a single integer n (1 <= n <= 2 * 10^5),
the length of the array.

The second line contains n distinct integers a[0], a[1], ..., a[n-1],
where 1 <= a[i] <= 10^9.

Output
-------
Print a single integer: the minimum number of operations needed to make
the array sorted in non-decreasing order using the allowed moves.

Example
--------
Input:
4
1 3 2 4

Output:
2

Explanation:
One optimal sequence of moves is:
- Move element 3 to the back  -> [1, 2, 4, 3]
- Move element 3 (last element) to the back again -> [1, 2, 3, 4]
So the minimum number of operations is 2.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Time limit: 1.00 s
Memory limit: 512 MB

A substring is called special if every character that appears in the string
appears the same number of times in the substring.
Your task is to count the number of special substrings in a given string.

Input
The only input line has a string of length n. Every character is between a...z.

Output
Print one integer: the number of special substrings.

Constraints
1 ≤ n ≤ 2 · 10^5

Example
Input:
abccabab

Output:
5

Explanation:
The special substrings are:
abc, cab, abccab, bccaba and ccabab.



xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

You are given an interaction log as an array `log` of length `n` and an integer `iterations`.

You need to perform the following operation exactly `iterations` times:

For each operation index `i` (0-based):

    i1 = i % n
    i2 = n - 1 - i1

    log[i1] = log[i1] XOR log[i2]

where XOR is the bitwise exclusive OR operation.

After performing all `iterations` operations, return the final state of the array `log`.

----------------------------------------------------
Details of the operation:

- `i1` walks from left to right repeatedly:
      0, 1, 2, ..., n-1, 0, 1, 2, ...

- `i2` is the mirrored index of `i1` from the right:
      i2 = n - 1 - i1
  so pairs are: (0, n-1), (1, n-2), (2, n-3), ...

- On each step `i`, only `log[i1]` is updated:
      log[i1] = log[i1] XOR log[i2]
  `log[i2]` is not directly changed in that step.

Your task is to compute the final array efficiently. Note that `iterations`
can be as large as 10^12, so a simple loop from 0 to `iterations - 1`
will be too slow and will not pass all test cases.

You must return the resulting array after all operations.

----------------------------------------------------
Example 1:

Input:
    n = 4
    log = [5, 6, 7, 8]
    iterations = 3

Process:
    i = 0:
        i1 = 0 % 4 = 0
        i2 = 4 - 1 - 0 = 3
        log[0] = 5 XOR 8 = 13
        log becomes [13, 6, 7, 8]

    i = 1:
        i1 = 1 % 4 = 1
        i2 = 4 - 1 - 1 = 2
        log[1] = 6 XOR 7 = 1
        log becomes [13, 1, 7, 8]

    i = 2:
        i1 = 2 % 4 = 2
        i2 = 4 - 1 - 2 = 1
        log[2] = 7 XOR 1 = 6
        log becomes [13, 1, 6, 8]

Output:
    [13, 1, 6, 8]

----------------------------------------------------
Example 2:

Input:
    n = 3
    log = [6, 1, 9]
    iterations = 7

After performing 7 operations as per the rules, the final array is:
    [6, 0, 15]

Output:
    [6, 0, 15]

----------------------------------------------------
Function to implement (C++ style):

    vector<int> updateInteractionLog(vector<int> log, long long iterations);

The function should return the final state of `log` after `iterations` operations.



XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Title: Minimum Removals to Make Array Balanced (with One Change)

Problem Statement
You are given an integer array nums of length n.

An array is called balanced if:
max(nums) <= 2 * min(nums)

You are allowed to perform the following operations:
1. Remove any number of elements from nums.
2. Change at most one element in nums to any positive integer you choose.

Return the minimum number of elements that must be removed so that the remaining array becomes balanced.

Notes:
- After removals and the optional change, the remaining array must be non-empty.
- The changed value must be a positive integer.

Example 1
Input: nums = [7, 4, 2, 3, 12, 9]
Output: 2
Explanation:
Remove 12 and 9. The remaining array [2, 3, 4, 7] can be made balanced by changing 7 to 4,
resulting in [2, 3, 4, 4], where max = 4 and min = 2, and 4 <= 2*2.

Example 2
Input: nums = [1, 2, 2, 3]
Output: 0
Explanation:
The array is already balanced since max = 3 and min = 1, and 3 <= 2*1.

Constraints
- 1 <= n <= 2 * 10^5
- 1 <= nums[i] <= 10^9

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

E - Minimum Swap
Time Limit: 2 sec / Memory Limit: 1024 MiB

Score:
475 points

Problem Statement
You are given an integer sequence
P = (P1, P2, ..., PN) that is a permutation of (1, 2, ..., N). Here, it is guaranteed that
P is not equal to (1, 2, ..., N).

You want to perform the following operation zero or more times to make
P match the sequence (1, 2, ..., N):

Choose a pair of integers (i, j) satisfying 1 <= i < j <= N. Swap the values of Pi and Pj.
Let K be the minimum number of operations required to make P match the sequence (1, 2, ..., N).

Find the number of operations that can be the first operation in a sequence of operations that makes P match
the sequence (1, 2, ..., N) in K operations. Two operations are distinguished if and only if the chosen pairs
of integers (i, j) are different.

Constraints
2 <= N <= 3 * 10^5
1 <= Pi <= N (1 <= i <= N)
Pi != Pj (1 <= i < j <= N)
There exists 1 <= i <= N such that i != Pi
All input values are integers.

Input
The input is given from Standard Input in the following format:

N
P1 P2 ... PN

Output
Print the answer.

Sample Input 1
5
3 1 4 2 5

Sample Output 1
6

Sample Input 2
2
2 1

Sample Output 2
1

Sample Input 3
20
15 5 13 17 9 11 20 4 14 16 6 3 8 19 12 7 10 18 2 1

Sample Output 3
77

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

F - 1122 Subsequence 2
Time Limit: 2 sec / Memory Limit: 1024 MiB

Score :
500 points

Problem Statement
You are given a string S consisting of digits.

A string T is called a 1122-string if it satisfies all of the following conditions. (The definition is the same as in Problem C.)

- T is a non-empty string consisting of digits.
- |T| is even, where |T| denotes the length of string T.
- All characters from the 1st through the |T|/2-th character of T are the same digit.
- All characters from the (|T|/2 + 1)-th through the |T|-th character of T are the same digit.
- Adding 1 to the digit of the 1st character of T gives the digit of the |T|-th character.

For example, 1122, 01, and 444555 are 1122-strings, but 1222 and 90 are not 1122-strings.

Find the number, modulo 998244353, of (not necessarily contiguous) subsequences of S that are 1122-strings.

Two subsequences are counted separately if they are extracted from different positions, even if they are identical as strings.

Constraints
S is a string consisting of digits with length between 1 and 10^6, inclusive.

Input
The input is given from Standard Input in the following format:

S

Output
Output the number, modulo 998244353, of subsequences of S that are 1122-strings.

Sample Input 1
1122

Sample Output 1
5

The following five subsequences satisfy the condition.

- 12 extracted from the 1st and 3rd characters of S
- 12 extracted from the 1st and 4th characters of S
- 12 extracted from the 2nd and 3rd characters of S
- 12 extracted from the 2nd and 4th characters of S
- 1122 extracted from the 1st through 4th characters of S

Thus, output 5.

Note that two subsequences are counted separately if they are extracted from different positions, even if they are identical as strings.

Sample Input 2
2025

Sample Output 2
0

Sample Input 3
0777468889971

Sample Output 3
30

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Plan Production
Problem Description
You must plan production for a company that manufactures multiple products. Each product has two associated costs:
- A worst-case cost that must be available before production begins.
- An expected cost that is actually spent during production.

Determine the minimum amount of starting cash needed to manufacture all products. Products can be produced in any order, and after completing each product, the remaining cash can be used for subsequent products.

Example
Given:
worstCase = [6, 5, 7]
expected = [4, 2, 1]

This can be represented as:
Product   worstCase   expected
0         6           4
1         5           2
2         7           1

The optimal production order is 2, 1, 0:
Start with 9 units of cash.
Produce product 2: requires 7 units worst-case, spends 1 unit expected.
Remaining cash: 9 - 1 = 8 units.
Produce product 1: requires 5 units worst-case, spends 2 units expected.
Remaining cash: 8 - 2 = 6 units.
Produce product 0: requires 6 units worst-case, spends 4 units expected.
Remaining cash: 6 - 4 = 2 units.
Therefore, the minimum starting amount is 9 units of cash.

Function Description
Complete the function planProduction in the editor. It has the following parameter(s):
int worstCase[n]: the minimum cash-on-hand to produce each product.
int expected[n]: the expected cost to produce each product.

Returns
long: the minimum starting cash required.

Constraints
1 ≤ n ≤ 10^5
1 ≤ worstCase[i] ≤ 10^5
1 ≤ expected[i] ≤ 10^5
It is guaranteed that expected[i] ≤ worstCase[i] for every i (0 ≤ i < n).

Sample Cases

Sample Case 0
Input
worstCase = [6, 5, 7, 8]
expected = [4, 2, 1, 1]
Output
10
Explanation
The optimal order to produce all products is (3, 2, 1, 0). This requires minimum starting funds of 10.
Start with 10. To produce product 3, we need at least 8 (10 ≥ 8). After production, cash is 10 - 1 = 9.
Current cash is 9. To produce product 2, we need at least 7 (9 ≥ 7). After production, cash is 9 - 1 = 8.
Current cash is 8. To produce product 1, we need at least 5 (8 ≥ 5). After production, cash is 8 - 2 = 6.
Current cash is 6. To produce product 0, we need at least 6 (6 ≥ 6). After production, cash is 6 - 4 = 2.

Sample Case 1
Input
worstCase = [6, 7, 8]
expected = [4, 4, 7]
Output
16
Explanation
The optimal order to produce all products is (1, 0, 2). This requires minimum starting funds of 16.
Start with 16. To produce product 1, we need at least 7 (16 ≥ 7).
After production, cash is 16 - 4 = 12.
Current cash is 12. To produce product 0, we need at least 6 (12 ≥ 6). After production, cash is 12 - 4 = 8.
Current cash is 8. To produce product 2, we need at least 8 (8 ≥ 8). After production, cash is 8 - 7 = 1.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Count Triplets with Bounded Difference

Problem Description
You are given an array of integers arr and a number d. Select a group of three elements where the difference between the largest and smallest values in the group is at most d.
Return the total number of such groups, modulo (10^9 + 7).

Examples

Example 1
Input: arr = [-3, -2, -1, 0], d = 2
Output: 2
Explanation:
All Valid Triplets
1) [-3, -2, -1]  max diff = (-1) - (-3) = 2
2) [-2, -1, 0]   max diff = 0 - (-2) = 2

Example 2
Input: arr = [2, 1, 3, 4], d = 3
Output: 4
Explanation:
All Valid Triplets
1) [2, 1, 3]  max diff = 3 - 1 = 2
2) [2, 1, 4]  max diff = 4 - 1 = 3
3) [2, 3, 4]  max diff = 4 - 2 = 2
4) [1, 3, 4]  max diff = 4 - 1 = 3

Constraints
3 ≤ size of arr ≤ 2 * 10^5
1 ≤ d ≤ 10^9
-10^9 ≤ arr[i] ≤ 10^9

Function Signature (C++)
/*
 * Complete the 'countTripletsWithinDifference' function below.
 *
 * The function is expected to return an INTEGER.
 * The function accepts following parameters:
 *  1. INTEGER_ARRAY arr
 *  2. INTEGER d
 */
int countTripletsWithinDifference(vector<int> arr, int d) {

}


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Computer Store
Description
There are n computers lined up on shelves in the local computer store. The brands of computers may be different. The shop assistant thinks the likelihood of selling products increases when computers of the same brand are placed in adjacent positions. The shop assistant would like to make at most k swaps to maximize the number of computers of the same brand adjacent to each other. Help the shop assistant to do that.

Input
The first line of input contains an integer n.
The second line of input contains an integer k.
The third line contains a string s of length n containing uppercase Latin letters. Each brand is represented with a single Latin letter in the given string.

Output
Print the maximum length of the adjacent computers of the same brand after making at most k swaps.

Constraints
1 ≤ n ≤ 50
1 ≤ k ≤ 2500

Examples
Example #1
Input:
4
1
ABCB
Output:
2
Explanation:
The shop assistant would like to make one swap, swapping the third and fourth computers. Therefore, we will obtain "ABBC", where the maximum length of adjacent same-brand computers will be 2.

Example #2
Input:
9
3
ABBABBABBA
Output:
4
Explanation:
"ABBBAABA" can be constructed using three swaps.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

You are given an integer N and a multiset of 3·N integers, where each integer is either 1, 2, or 3.

Your task is to determine whether it is possible to partition all 3·N numbers into exactly N groups (triplets) such that:
- each group contains exactly 3 numbers, and
- the sum of the three numbers in every group is the same.

For each test case, output:
- "Yes" if such a partition is possible,
- otherwise output "No".

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

You’re given an array P of size N which is a permutation of numbers 0 to N-1.

For every block size x from 1 to N:

1) If N is not divisible by x:
   - You cannot split the array into equal-sized consecutive blocks of length x,
   - so beauty(x) = 0.

2) If N is divisible by x:
   - Split P into exactly N/x consecutive blocks, each of length x.
   - For each block, compute its MEX:
       MEX = smallest non-negative integer (0,1,2,...) that is missing from that block.
   - Add all those MEX values (one from each block).
   - Multiply the sum by x → that is beauty(x).

Finally, output the total:
    beauty(1) + beauty(2) + ... + beauty(N)
modulo 1,000,000,007.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Question: Rod Offcut

Given an array of metal rod lengths, repeatedly perform the following steps:

1) Count the number of rods currently present.
2) Find the rod(s) with the shortest length.
3) Discard all rods having that shortest length.
4) From every remaining rod (each longer rod), cut off exactly the shortest length found in step 2,
   and discard the offcuts.
5) Repeat until no rods remain.

Return an array containing the number of rods at the beginning of each round (step 1 of every round).

Function to implement:
rodOffcut(lengths)

Input Format (Custom Testing):
- The first line contains an integer n, the number of elements in lengths.
- The next n lines each contain an integer lengths[i] (0 <= i < n).

Output Format:
- Print the returned array values (number of rods at the start of each round), one per line.

Constraints:
- 1 <= n <= 10^3
- 1 <= lengths[i] <= 10^3

Example:
n = 4
lengths = [1, 1, 3, 4]

Round 1: rods = 4, shortest = 1 -> discard two 1s, cut 1 from [3,4] -> [2,3]
Round 2: rods = 2, shortest = 2 -> discard 2, cut 2 from [3] -> [1]
Round 3: rods = 1, shortest = 1 -> discard 1 -> []

Answer: [4, 2, 1]

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
