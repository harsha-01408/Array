782. Avoid "suspected robbery"

Small towns are distributed along the street (which can be understood as all on the number axis), with N banks (the location is represented by the coordinates of the number axis, and the amount represents the amount that can be robbed).

The two kidnappers tried to rob a bank each, and in order to get the police to travel more, they agreed to choose two banks not less than apart D.

Excuse me, what is the maximum total amount they can grab if they meet the agreement.

Input format
Input contains N + 1 lines.

The first line contains two integers N and D, indicating the number of banks and the agreed distance respectively.

Next N lines, each containing two integers A and B, indicating the coordinates and the amount respectively.

Output format
Output a number indicating the maximum amount that can be obtained.

Data scope
1 ≤ N ≤ 2 × 10^5
1 ≤ D, A, B ≤ 10^8

The data guarantee that at least two banks are present at a distance of not less than D.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

1454. Number of Subsets with Prime XOR Sum

You are given n distinct positive integers.

Count how many subsets of these integers have their XOR-sum equal to a prime number.

Since the answer can be very large, output it modulo 10^9 + 7.

Input

The first line contains an integer n.

The second line contains n distinct positive integers.

Output

Output a single integer — the number of subsets whose XOR-sum is prime, modulo 10^9 + 7.

Constraints

1 ≤ n ≤ 5000

1 ≤ each integer ≤ 5000

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

756. Serpentine Matrix

Enter two integers N and M, output an N × M matrix.
Fill the numbers from 1 to N × M into the matrix in a backward serpentine (spiral) order.

You can refer to the sample example for the specific filling pattern.

Input format

A single line containing two integers N and M.

Output format

Output an N × M matrix that meets the requirement.

The matrix has N rows, and each row contains M integers separated by spaces.

Data constraints

1 ≤ N, M ≤ 100

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXxxxxxxxxxxxxxxxxxx

Problem 1487: Coin Selection

Problem Statement:
You are given n1 + n2 types of coins. 
- The first n1 types are ordinary coins, which you can pick any number of times.
- The next n2 types are commemorative coins, of which you can pick at most 1 coin of each type. 
Each coin has a positive integer face value.  

Your task is to find the number of ways to form a total sum of exactly m using these coins. 
Output the result modulo 10^9 + 7.

Input Format:
- First line: three integers n1, n2, m 
  (number of ordinary coins, number of commemorative coins, target sum)
- Second line: n1 integers a[1..n1], the face values of ordinary coins (strictly increasing)
- Third line: n2 integers b[1..n2], the face values of commemorative coins (strictly increasing)

Output Format:
- One integer x: the total number of ways to form sum m modulo 10^9 + 7.

Constraints:
- For 30% of data: 1 ≤ n1+n2 ≤ 10, 1 ≤ m ≤ 100, 1 ≤ a[i], b[i] ≤ 100
- For 100% of data: 1 ≤ n1+n2 ≤ 100, 1 ≤ m ≤ 100000, 1 ≤ a[i], b[i] ≤ 100000

Sample Input:
3 1 5
1 2 3
1

Sample Output:
9

Explanation:
(x) denotes ordinary coins, [x] denotes commemorative coins. All ways to make sum 5:
(1)(1)(1)(1)(1)
(1)(1)(1)(2)
(1)(1)(3)
(1)(2)(2)
(2)(3)
(1)(1)(1)(1)[1]
(1)(1)(1)(2)

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

730. Robot Jumping Problem

A robot is playing an old DOS-based game.

In the game, there are N+1 buildings indexed from 0 to N, arranged from left to right.

The height of building 0 is 0 units.

The height of building i (where i ≥ 1) is given by H(i) units.

Initially, the robot starts at building 0.

At each step, the robot jumps to the next building (i.e., from building k to building k+1).

Energy Requirement:

Assume the robot is at building k and its current energy is E.

When it jumps to building k+1, if the height of building k+1 (H(k+1)) is greater than E, the robot loses energy equal to the difference H(k+1) - E.

If the height of building k+1 is less than or equal to E, the robot gains energy equal to E - H(k+1).

Goal:

The robot’s goal is to reach building N. The robot’s energy should never go below 0 during the journey.

Problem:

Given the heights of the buildings, find the minimum initial energy E the robot must have in order to reach building N without ever running out of energy.

Input Format:

The first line contains an integer N.

The second line contains N integers, representing the heights of the buildings (from building 1 to building N).

Output Format:

Output the minimum initial energy E (rounded up to the nearest integer) required for the robot to reach building N.

Constraints:

1 ≤ N ≤ 100,000

1 ≤ H(i) ≤ 1,000,000,000

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem Description:

In a small town, there are n banks, and each bank is located along a straight line (on the number axis). Each bank has a position and an amount of money that can be stolen from them.

Two robbers are trying to rob two different banks. However, to make the police chase them more effectively, they agree that the distance between the two banks they rob must be at least d.

Your task is to determine the maximum amount of money they can steal while following the constraint of the minimum distance between the two robbed banks.

Input Format:

The first line contains two integers n and d, representing the number of banks and the minimum distance between the two banks that the robbers can rob.

The next n lines each contain two integers:

a: The position of a bank on the number line.

b: The amount of money available at that bank, respectively.

Output Format:

Output a single integer, which is the maximum total amount of money the two robbers can steal.

Constraints:

1 ≤ n ≤ 200,000

1 ≤ d, a, b ≤ 100,000,000

Note: It is guaranteed that there are at least two banks whose distance is not less than d.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

NAJ0001 - Divisible Number Sum

Hazzat is a new guy in computer science, now in his 3rd semester. He recently completed a data structures course but keeps encountering problems he can't solve with the structures he knows. He wants to establish a new data structure but keeps failing. Help Hazzat by solving the following problem.

You are given an array A of N integers. You need to answer M queries.

Each query is of the form: V x y

For each query, consider the subarray A[x..y] (1-based indices). Let S be the subset of elements in this range that are fully divisible by V; i.e., include A[i] in S if x ≤ i ≤ y and A[i] % V == 0. Output the sum of all elements in S.

Input
- The first line contains an integer T (1 ≤ T ≤ 5) — the number of test cases.
For each test case:
- A line with two integers N and M (1 ≤ N ≤ 10^5, 1 ≤ M ≤ 2×10^5).
- A line with N integers: A[1], A[2], ..., A[N] (1 ≤ A[i] ≤ 10^6).
- Then M lines follow, each with three integers V, x, y (1 ≤ V ≤ 1000, 1 ≤ x ≤ y ≤ N).

Output
For each test case, print:
- A line: Case #k
- Then print M lines, each containing the answer for the corresponding query.
- Print a blank line between two consecutive test cases.

Sample Input
2
5 2
1 2 3 4 6
2 1 5
5 1 4
5 2
2 3 5 3 7
3 2 4
5 1 5

Sample Output
Case #1
12
0

Case #2
6
5

Explanation
- Query 1 of Case #1: In A[1..5], the divisible-by-2 elements are {2, 4, 6}; their sum is 12.
- Query 2 of Case #1: In A[1..4], there are no elements divisible by 5; the sum is 0.

Note
Data set is large. Use fast I/O.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Minimum Distinct People Seen

You are the guard of a shop. Over time, people enter and leave. You record a binary string s:

- s[i] = '1'  → a person enters at time i
- s[i] = '0'  → a person leaves at time i

A person may enter and leave any number of times.
Using only this information, determine the minimum possible number of distinct people you might have seen.

Task:
Given s, compute the smallest number of distinct individuals consistent with the sequence of enters/leaves.

Input:
- A single binary string s (1 ≤ |s| ≤ 10^5)

Output:
- A single integer: the minimum possible number of distinct people seen.

Constraints:
- 1 ≤ len(s) ≤ 10^5
- s consists only of characters '0' and '1'

Notes:
- Multiple test strings may be provided one per line (if desired), each to be processed independently.

Examples:

Example 1
Input:
000
Output:
3
Explanation:
t=1: person A leaves
t=2: person B leaves
t=3: person C leaves
Thus 3 distinct people.

Example 2
Input:
110011
Output:
2
Explanation:
t=1: P1 enters
t=2: P2 enters
t=3: P1 leaves
t=4: P2 leaves
t=5: P1 enters
t=6: P2 enters
Minimum distinct people = 2.

Example 3
Input:
10101
Output:
1
Explanation:
One person alternates entering and leaving; only 1 distinct person is needed.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Count Good Strings

You are given a string s of length n (1 ≤ n ≤ 10^4).  
Each character of s is either a digit '0'–'9' or a question mark '?'.

You may replace every '?' with any digit from 0 to 9.  
A string is called GOOD if, when interpreted as a (possibly leading-zero) decimal number, it leaves remainder 7 when divided by 11 AND also leaves remainder 7 when divided by 13.

Task:
Count how many different strings can be obtained by replacing '?' such that the resulting number is GOOD.

Notes:
- Leading zeros are allowed (unless otherwise specified).
- Equivalently, a GOOD string represents a number congruent to 7 modulo 11 and 13 (i.e., modulo 143).

Input:
A single line containing the string s.

Output:
A single integer — the number of GOOD strings.

Constraints:
1 ≤ n ≤ 10^4  
s[i] ∈ {'0','1',…,'9','?'}

Examples:

Example 1
Input:
??756
Output:
1
Explanation:
Only one completion works: 34756.

Example 2
Input:
??33?
Output:
10
Explanation:
There are 10 completions such that the number is ≡ 7 mod 11 and ≡ 7 mod 13 (e.g., 42335, 46339, and 8 others).


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem: Largest Contiguous Subarray (Lexicographic)

Definition:
- For two arrays A and B of the same length, A > B if at the first index where they differ,
  A[i] > B[i]. (This is standard lexicographic order.)
- A contiguous subarray uses consecutive indices.

Task:
Given an integer array arr of length n and an integer k (1 ≤ k ≤ n),
return (or print) the lexicographically largest contiguous subarray of length k
among all subarrays arr[i..i+k-1] (0 ≤ i ≤ n-k).

Input Format:
- Line 1: integer n
- Line 2: n space-separated integers arr[i]
- Line 3: integer k

Output Format:
- One line with k space-separated integers: the lexicographically largest contiguous subarray of length k.

Constraints:
- 1 ≤ k ≤ n ≤ 100
- 1 ≤ arr[i] ≤ 1000

Example:
Input
5
1 4 3 2 5
4

Output
4 3 2 5

Explanation:
Possible subarrays of size 4: [1,4,3,2] and [4,3,2,5].
Comparing lexicographically, [4,3,2,5] is larger.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Interesting Pairs of Numbers

Given an array of integers arr and an integer sumVal, count the number of unordered
index pairs (i, j) with i < j such that:

    |arr[i] - arr[j]| + |arr[i] + arr[j]| = sumVal

An unordered pair (i, j) is called “interesting” if it satisfies the above condition.

Example:
- arr = [1, 4, -1, 2]
- sumVal = 4
Interesting pairs: (1,4) and (3,4)
Because:
|arr1 - arr4| + |arr1 + arr4| = |1 - 2| + |1 + 2| = 4
|arr3 - arr4| + |arr3 + arr4| = |-1 - 2| + |-1 + 2| = 4

Function Description
Complete the function:
    long long findInterestingPairs(const vector<int>& arr, int sumVal);

Parameters:
- arr[n]: array of integers
- sumVal: integer

Returns:
- A single integer/long long: the number of interesting pairs.

Constraints:
- 1 ≤ n ≤ 1e5
- -1e6 ≤ arr[i] ≤ 1e6
- 1 ≤ sumVal ≤ 1e6

Input Format (for custom testing):
n
arr[0]
arr[1]
...
arr[n-1]
sumVal

Output Format:
A single integer: the count of interesting pairs.

Sample Input 0:
4
1
3
2
0
2

Sample Output 0:
1

Explanation:
Only one interesting pair: (1,4),
since |1 - 0| + |1 + 0| = 1 + 1 = 2.

Sample Input 1:
4
1
4
-1
2
4

Sample Output 1:
2

Explanation:
Pairs (1,4) and (3,4) satisfy the condition (shown above).


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Women Leading

Shakuntala Devi once asked her students sitting in a lecture room to analyze seating rows.
For each row (a string consisting only of 'W' for Women and 'M' for Men), determine the
maximum length of a contiguous block that consists of k consecutive 'W' followed immediately
by k consecutive 'M' (for some k ≥ 1). In other words, find the longest substring of the
form W^k M^k and report its length (which is 2k). If no such substring exists, print -1.

Input Format
- The first line contains an integer R — the number of rows.
- Each of the next R lines contains a string S made up of only 'W' and 'M'.

Output Format
- For each row, print a single integer: the maximum length of a substring of the form
  W^k M^k (k ≥ 1); print -1 if it is not possible.

Constraints
- 1 ≤ R ≤ 10
- 1 ≤ |S| ≤ 10^5

Sample Input
2
WWMMMWMWMMMMMWWWWWWWWMMW
MMMWW

Sample Output
6
-1

Explanation
Row 1: The longest contiguous block of Women followed by Men with equal counts is "WWWMMM",
so the length is 6.
Row 2: There is no substring of the form W^k M^k, hence -1.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Maximum Partition

You are given an array A of N integers (1-based indexing). You may split the array into any number K (K ≥ 1) of
contiguous partitions so that together they cover the whole array in order.

If the partition sums are P1, P2, …, PK, define the “special sum” of the partitioning as:
    P1 − P2 + P3 − P4 + … + (−1)^(K−1) · PK
(i.e., start with +, then alternate −, +, −, …).

Task
Choose a partitioning that maximizes the special sum and output that maximum value.

Notes
• Partitions must be contiguous and in order (no reordering of elements).
• 1-based indexing is assumed in any explanation.

Input Format
• The first line contains an integer N.
• The second line contains N space-separated integers A1, A2, …, AN.

Output Format
• Print a single integer: the maximum achievable special sum.

Constraints
• 1 ≤ N ≤ 10^5
• −10^5 ≤ Ai ≤ 10^6  for all i in [1, N]

Example
Input
5
-1 -2 3 2 9

Output
9

Explanation
One optimal partitioning is: [−1] | [−2, 3] | [2, 9]
Here, P1 = −1, P2 = (−2 + 3) = 1, P3 = (2 + 9) = 11
Special sum = P1 − P2 + P3 = (−1) − 1 + 11 = 9

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Interleaving Subsequences Count

Given three lowercase strings p, q, and r (length ≤ 100), count the number of ways to form
exactly the string r by interleaving a subsequence of p and a subsequence of q, while
preserving the relative order of characters taken from each string. You must use at least
one character from p and at least one character from q. Return the answer modulo 1,000,000,007.

Notes
- “Subsequence” means you may skip characters but cannot reorder them.
- The two chosen subsequences (one from p, one from q) are interleaved to form r.
- At least one character must be taken from each of p and q.

Input Format
- Line 1: string p
- Line 2: string q
- Line 3: string r

Output Format
- A single integer: the number of valid interleavings modulo 1,000,000,007.

Constraints
- 1 ≤ |p|, |q|, |r| ≤ 100
- All strings consist only of lowercase English letters.

Sample
p: ab
q: ba
r: aba

Output:
2

Explanation:
Two valid ways to form "aba":
1) take "a" from p, then "ba" from q
2) take "ab" from p, then "a" from q


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Maximize Subarray-Sum × Pivot Value

Given an array arr of length n, find the maximum possible value of:
    ( sum(arr[i..j]) ) × arr[k]
over all choices of indices i, j, k such that 0 ≤ i ≤ k ≤ j < n.

Input Format
- Line 1: integer n
- Line 2: n space-separated integers arr[0], arr[1], …, arr[n-1]

Output Format
- Print a single integer: the maximum value of (sum of a subarray) multiplied by
  the value at some index k that lies inside that subarray.
  Use 64-bit arithmetic for safety.

Constraints
- 1 ≤ n ≤ 5 × 10^5
- −10^6 ≤ arr[i] ≤ 10^6

Example
Input
5
2 -1 3 -2 4
Output
16

Explanation
Best is to choose subarray [0..4] with sum 6 and k = 4 (arr[k] = 4):
6 × 4 = 24; but even better is subarray [2..4] with sum 5 and k = 4: 5 × 4 = 20.
(Your result should be the maximum over all valid (i, j, k); values can be negative too.)


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem — Minimize Spread After 4-Way Split

You are given an integer N and an array X of N integers (X1 … XN).
Place exactly three cut positions to split X into four **non-empty, contiguous**
subarrays. Let A, B, C, and D be the sums of those four parts (in order).

Your task is to output the **minimum possible value** of:
    max(A, B, C, D) − min(A, B, C, D)

Input Format
• N
• X1 X2 … XN

Output Format
• A single integer: the minimum possible value of max(A,B,C,D) − min(A,B,C,D).

Constraints
• 4 ≤ N ≤ 2⋅10^5
• 0 ≤ Xi ≤ 10^9

Sample 1
Input
5
4 3 5 2 3
Output
2
Explanation
Split as (4) | (3) | (5) | (2,3) → A=4, B=3, C=5, D=5 → 5 − 3 = 2.

Sample 2
Input
7
3 2 1 11 12 5 9
Output
7

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem — Max Equalizable Count with ±1 Operations

You are given an array A of N integers.

For each element Ai you may perform exactly one of the following:
• Add 1 to Ai
• Subtract 1 from Ai
• Do nothing to Ai

After applying these choices to all elements, you may choose any integer K.
Count how many elements are equal to K. Your task is to find the **maximum**
possible count.

Input Format
• The first line contains a single integer N.
• The second line contains N integers: A1 A2 … AN.

Constraints
• 1 ≤ N ≤ 100000
• 0 ≤ Ai ≤ 100000

Output Format
• Print a single integer — the maximum possible number of elements that can be made equal to some K.

Sample
Input
7
3 1 4 1 5 9 2
Output
4
Explanation
Choose K = 2. Values originally equal to 1, 2, or 3 can be turned into 2.
There are 2 (ones) + 1 (two) + 1 (three) = 4 such elements.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Playlist Fun Maximization

You have n songs. The i-th song has:
  - singer[i]: an integer ID of its singer
  - length[i]: its duration (positive integer)

You may reorder the songs arbitrarily. While listening, the fun gained from the
t-th played song equals:
    (# of distinct singers heard among the first t songs) × length of that song.

Goal:
Choose an order that maximizes the total fun
    sum_{t=1..n} (distinct_singers_so_far) * length[ song_at_position_t ],
and return that maximum value.

Constraints
1 ≤ n ≤ 10^5
1 ≤ singer[i] ≤ 10^9
1 ≤ length[i] ≤ 10^9

Example 1
n = 3
singer = [1, 2, 2]
length = [2, 3, 2]
Optimal order: first song (1,2), third song (2,2), second song (2,3)
Fun: 1*2 + 2*2 + 2*3 = 2 + 4 + 6 = 12
Answer: 12

Example 2
n = 3
singer = [1, 1, 2]
length = [5, 4, 3]
Optimal order: second song (1,4), third song (2,3), first song (1,5)
Fun: 1*4 + 2*3 + 2*5 = 4 + 6 + 10 = 20
Answer: 20


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Arranging Numbers (Beautiful Arrangement)

Jayme has the numbers 1..n. A permutation a[1..n] (1-based) is called
“beautiful” if for every position i (1 ≤ i ≤ n) at least one holds:
  - a[i] is divisible by i, OR
  - i is divisible by a[i].
(i.e., a[i] % i == 0 or i % a[i] == 0)

Task:
Count how many beautiful permutations of {1, 2, …, n} exist and return that count.

Input
- A single integer n

Output
- A single integer: the number of beautiful arrangements

Constraints
- 1 < n < 20

Example
Input:
2
Output:
2
Explanation:
Permutations [1,2] and [2,1] both satisfy the divisibility condition at each position.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Element Swapping

Given an array arr of n integers, you may perform the following operation any number of times:
1) Choose an index i (0 ≤ i < n − 1) and swap arr[i] and arr[i + 1].
2) Each element can be swapped at most once during the whole process (i.e., no element participates in more than one swap).

The strength of index i is defined as arr[i] × (i + 1), using 0-based indexing.

Goal:
Find the maximum possible value of
    S = Σ_{i=0}^{n−1} arr[i] × (i + 1)
after applying allowed swaps optimally. Return this maximum.

Example
n = 4
arr = [2, 1, 4, 3]

Optimal swaps:
- swap(arr[2], arr[3])
- swap(arr[0], arr[1])

Final array: [1, 2, 3, 4]
Sum of strengths: 1×1 + 2×2 + 3×3 + 4×4 = 30
Return 30.

Function Description
Complete the function getMaximumSumOfStrengths with the parameter:
    int arr[n]: the initial array
Returns:
    long int: the maximum possible sum of strengths of all indices after optimal swaps.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
