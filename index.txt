782. Avoid "suspected robbery"

Small towns are distributed along the street (which can be understood as all on the number axis), with N banks (the location is represented by the coordinates of the number axis, and the amount represents the amount that can be robbed).

The two kidnappers tried to rob a bank each, and in order to get the police to travel more, they agreed to choose two banks not less than apart D.

Excuse me, what is the maximum total amount they can grab if they meet the agreement.

Input format
Input contains N + 1 lines.

The first line contains two integers N and D, indicating the number of banks and the agreed distance respectively.

Next N lines, each containing two integers A and B, indicating the coordinates and the amount respectively.

Output format
Output a number indicating the maximum amount that can be obtained.

Data scope
1 ≤ N ≤ 2 × 10^5
1 ≤ D, A, B ≤ 10^8

The data guarantee that at least two banks are present at a distance of not less than D.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

1454. Number of Subsets with Prime XOR Sum

You are given n distinct positive integers.

Count how many subsets of these integers have their XOR-sum equal to a prime number.

Since the answer can be very large, output it modulo 10^9 + 7.

Input

The first line contains an integer n.

The second line contains n distinct positive integers.

Output

Output a single integer — the number of subsets whose XOR-sum is prime, modulo 10^9 + 7.

Constraints

1 ≤ n ≤ 5000

1 ≤ each integer ≤ 5000

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

756. Serpentine Matrix

Enter two integers N and M, output an N × M matrix.
Fill the numbers from 1 to N × M into the matrix in a backward serpentine (spiral) order.

You can refer to the sample example for the specific filling pattern.

Input format

A single line containing two integers N and M.

Output format

Output an N × M matrix that meets the requirement.

The matrix has N rows, and each row contains M integers separated by spaces.

Data constraints

1 ≤ N, M ≤ 100

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXxxxxxxxxxxxxxxxxxx

Problem 1487: Coin Selection

Problem Statement:
You are given n1 + n2 types of coins. 
- The first n1 types are ordinary coins, which you can pick any number of times.
- The next n2 types are commemorative coins, of which you can pick at most 1 coin of each type. 
Each coin has a positive integer face value.  

Your task is to find the number of ways to form a total sum of exactly m using these coins. 
Output the result modulo 10^9 + 7.

Input Format:
- First line: three integers n1, n2, m 
  (number of ordinary coins, number of commemorative coins, target sum)
- Second line: n1 integers a[1..n1], the face values of ordinary coins (strictly increasing)
- Third line: n2 integers b[1..n2], the face values of commemorative coins (strictly increasing)

Output Format:
- One integer x: the total number of ways to form sum m modulo 10^9 + 7.

Constraints:
- For 30% of data: 1 ≤ n1+n2 ≤ 10, 1 ≤ m ≤ 100, 1 ≤ a[i], b[i] ≤ 100
- For 100% of data: 1 ≤ n1+n2 ≤ 100, 1 ≤ m ≤ 100000, 1 ≤ a[i], b[i] ≤ 100000

Sample Input:
3 1 5
1 2 3
1

Sample Output:
9

Explanation:
(x) denotes ordinary coins, [x] denotes commemorative coins. All ways to make sum 5:
(1)(1)(1)(1)(1)
(1)(1)(1)(2)
(1)(1)(3)
(1)(2)(2)
(2)(3)
(1)(1)(1)(1)[1]
(1)(1)(1)(2)

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

730. Robot Jumping Problem

A robot is playing an old DOS-based game.

In the game, there are N+1 buildings indexed from 0 to N, arranged from left to right.

The height of building 0 is 0 units.

The height of building i (where i ≥ 1) is given by H(i) units.

Initially, the robot starts at building 0.

At each step, the robot jumps to the next building (i.e., from building k to building k+1).

Energy Requirement:

Assume the robot is at building k and its current energy is E.

When it jumps to building k+1, if the height of building k+1 (H(k+1)) is greater than E, the robot loses energy equal to the difference H(k+1) - E.

If the height of building k+1 is less than or equal to E, the robot gains energy equal to E - H(k+1).

Goal:

The robot’s goal is to reach building N. The robot’s energy should never go below 0 during the journey.

Problem:

Given the heights of the buildings, find the minimum initial energy E the robot must have in order to reach building N without ever running out of energy.

Input Format:

The first line contains an integer N.

The second line contains N integers, representing the heights of the buildings (from building 1 to building N).

Output Format:

Output the minimum initial energy E (rounded up to the nearest integer) required for the robot to reach building N.

Constraints:

1 ≤ N ≤ 100,000

1 ≤ H(i) ≤ 1,000,000,000

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem Description:

In a small town, there are n banks, and each bank is located along a straight line (on the number axis). Each bank has a position and an amount of money that can be stolen from them.

Two robbers are trying to rob two different banks. However, to make the police chase them more effectively, they agree that the distance between the two banks they rob must be at least d.

Your task is to determine the maximum amount of money they can steal while following the constraint of the minimum distance between the two robbed banks.

Input Format:

The first line contains two integers n and d, representing the number of banks and the minimum distance between the two banks that the robbers can rob.

The next n lines each contain two integers:

a: The position of a bank on the number line.

b: The amount of money available at that bank, respectively.

Output Format:

Output a single integer, which is the maximum total amount of money the two robbers can steal.

Constraints:

1 ≤ n ≤ 200,000

1 ≤ d, a, b ≤ 100,000,000

Note: It is guaranteed that there are at least two banks whose distance is not less than d.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

NAJ0001 - Divisible Number Sum

Hazzat is a new guy in computer science, now in his 3rd semester. He recently completed a data structures course but keeps encountering problems he can't solve with the structures he knows. He wants to establish a new data structure but keeps failing. Help Hazzat by solving the following problem.

You are given an array A of N integers. You need to answer M queries.

Each query is of the form: V x y

For each query, consider the subarray A[x..y] (1-based indices). Let S be the subset of elements in this range that are fully divisible by V; i.e., include A[i] in S if x ≤ i ≤ y and A[i] % V == 0. Output the sum of all elements in S.

Input
- The first line contains an integer T (1 ≤ T ≤ 5) — the number of test cases.
For each test case:
- A line with two integers N and M (1 ≤ N ≤ 10^5, 1 ≤ M ≤ 2×10^5).
- A line with N integers: A[1], A[2], ..., A[N] (1 ≤ A[i] ≤ 10^6).
- Then M lines follow, each with three integers V, x, y (1 ≤ V ≤ 1000, 1 ≤ x ≤ y ≤ N).

Output
For each test case, print:
- A line: Case #k
- Then print M lines, each containing the answer for the corresponding query.
- Print a blank line between two consecutive test cases.

Sample Input
2
5 2
1 2 3 4 6
2 1 5
5 1 4
5 2
2 3 5 3 7
3 2 4
5 1 5

Sample Output
Case #1
12
0

Case #2
6
5

Explanation
- Query 1 of Case #1: In A[1..5], the divisible-by-2 elements are {2, 4, 6}; their sum is 12.
- Query 2 of Case #1: In A[1..4], there are no elements divisible by 5; the sum is 0.

Note
Data set is large. Use fast I/O.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Minimum Distinct People Seen

You are the guard of a shop. Over time, people enter and leave. You record a binary string s:

- s[i] = '1'  → a person enters at time i
- s[i] = '0'  → a person leaves at time i

A person may enter and leave any number of times.
Using only this information, determine the minimum possible number of distinct people you might have seen.

Task:
Given s, compute the smallest number of distinct individuals consistent with the sequence of enters/leaves.

Input:
- A single binary string s (1 ≤ |s| ≤ 10^5)

Output:
- A single integer: the minimum possible number of distinct people seen.

Constraints:
- 1 ≤ len(s) ≤ 10^5
- s consists only of characters '0' and '1'

Notes:
- Multiple test strings may be provided one per line (if desired), each to be processed independently.

Examples:

Example 1
Input:
000
Output:
3
Explanation:
t=1: person A leaves
t=2: person B leaves
t=3: person C leaves
Thus 3 distinct people.

Example 2
Input:
110011
Output:
2
Explanation:
t=1: P1 enters
t=2: P2 enters
t=3: P1 leaves
t=4: P2 leaves
t=5: P1 enters
t=6: P2 enters
Minimum distinct people = 2.

Example 3
Input:
10101
Output:
1
Explanation:
One person alternates entering and leaving; only 1 distinct person is needed.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Count Good Strings

You are given a string s of length n (1 ≤ n ≤ 10^4).  
Each character of s is either a digit '0'–'9' or a question mark '?'.

You may replace every '?' with any digit from 0 to 9.  
A string is called GOOD if, when interpreted as a (possibly leading-zero) decimal number, it leaves remainder 7 when divided by 11 AND also leaves remainder 7 when divided by 13.

Task:
Count how many different strings can be obtained by replacing '?' such that the resulting number is GOOD.

Notes:
- Leading zeros are allowed (unless otherwise specified).
- Equivalently, a GOOD string represents a number congruent to 7 modulo 11 and 13 (i.e., modulo 143).

Input:
A single line containing the string s.

Output:
A single integer — the number of GOOD strings.

Constraints:
1 ≤ n ≤ 10^4  
s[i] ∈ {'0','1',…,'9','?'}

Examples:

Example 1
Input:
??756
Output:
1
Explanation:
Only one completion works: 34756.

Example 2
Input:
??33?
Output:
10
Explanation:
There are 10 completions such that the number is ≡ 7 mod 11 and ≡ 7 mod 13 (e.g., 42335, 46339, and 8 others).


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem: Largest Contiguous Subarray (Lexicographic)

Definition:
- For two arrays A and B of the same length, A > B if at the first index where they differ,
  A[i] > B[i]. (This is standard lexicographic order.)
- A contiguous subarray uses consecutive indices.

Task:
Given an integer array arr of length n and an integer k (1 ≤ k ≤ n),
return (or print) the lexicographically largest contiguous subarray of length k
among all subarrays arr[i..i+k-1] (0 ≤ i ≤ n-k).

Input Format:
- Line 1: integer n
- Line 2: n space-separated integers arr[i]
- Line 3: integer k

Output Format:
- One line with k space-separated integers: the lexicographically largest contiguous subarray of length k.

Constraints:
- 1 ≤ k ≤ n ≤ 100
- 1 ≤ arr[i] ≤ 1000

Example:
Input
5
1 4 3 2 5
4

Output
4 3 2 5

Explanation:
Possible subarrays of size 4: [1,4,3,2] and [4,3,2,5].
Comparing lexicographically, [4,3,2,5] is larger.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Interesting Pairs of Numbers

Given an array of integers arr and an integer sumVal, count the number of unordered
index pairs (i, j) with i < j such that:

    |arr[i] - arr[j]| + |arr[i] + arr[j]| = sumVal

An unordered pair (i, j) is called “interesting” if it satisfies the above condition.

Example:
- arr = [1, 4, -1, 2]
- sumVal = 4
Interesting pairs: (1,4) and (3,4)
Because:
|arr1 - arr4| + |arr1 + arr4| = |1 - 2| + |1 + 2| = 4
|arr3 - arr4| + |arr3 + arr4| = |-1 - 2| + |-1 + 2| = 4

Function Description
Complete the function:
    long long findInterestingPairs(const vector<int>& arr, int sumVal);

Parameters:
- arr[n]: array of integers
- sumVal: integer

Returns:
- A single integer/long long: the number of interesting pairs.

Constraints:
- 1 ≤ n ≤ 1e5
- -1e6 ≤ arr[i] ≤ 1e6
- 1 ≤ sumVal ≤ 1e6

Input Format (for custom testing):
n
arr[0]
arr[1]
...
arr[n-1]
sumVal

Output Format:
A single integer: the count of interesting pairs.

Sample Input 0:
4
1
3
2
0
2

Sample Output 0:
1

Explanation:
Only one interesting pair: (1,4),
since |1 - 0| + |1 + 0| = 1 + 1 = 2.

Sample Input 1:
4
1
4
-1
2
4

Sample Output 1:
2

Explanation:
Pairs (1,4) and (3,4) satisfy the condition (shown above).


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Women Leading

Shakuntala Devi once asked her students sitting in a lecture room to analyze seating rows.
For each row (a string consisting only of 'W' for Women and 'M' for Men), determine the
maximum length of a contiguous block that consists of k consecutive 'W' followed immediately
by k consecutive 'M' (for some k ≥ 1). In other words, find the longest substring of the
form W^k M^k and report its length (which is 2k). If no such substring exists, print -1.

Input Format
- The first line contains an integer R — the number of rows.
- Each of the next R lines contains a string S made up of only 'W' and 'M'.

Output Format
- For each row, print a single integer: the maximum length of a substring of the form
  W^k M^k (k ≥ 1); print -1 if it is not possible.

Constraints
- 1 ≤ R ≤ 10
- 1 ≤ |S| ≤ 10^5

Sample Input
2
WWMMMWMWMMMMMWWWWWWWWMMW
MMMWW

Sample Output
6
-1

Explanation
Row 1: The longest contiguous block of Women followed by Men with equal counts is "WWWMMM",
so the length is 6.
Row 2: There is no substring of the form W^k M^k, hence -1.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Maximum Partition

You are given an array A of N integers (1-based indexing). You may split the array into any number K (K ≥ 1) of
contiguous partitions so that together they cover the whole array in order.

If the partition sums are P1, P2, …, PK, define the “special sum” of the partitioning as:
    P1 − P2 + P3 − P4 + … + (−1)^(K−1) · PK
(i.e., start with +, then alternate −, +, −, …).

Task
Choose a partitioning that maximizes the special sum and output that maximum value.

Notes
• Partitions must be contiguous and in order (no reordering of elements).
• 1-based indexing is assumed in any explanation.

Input Format
• The first line contains an integer N.
• The second line contains N space-separated integers A1, A2, …, AN.

Output Format
• Print a single integer: the maximum achievable special sum.

Constraints
• 1 ≤ N ≤ 10^5
• −10^5 ≤ Ai ≤ 10^6  for all i in [1, N]

Example
Input
5
-1 -2 3 2 9

Output
9

Explanation
One optimal partitioning is: [−1] | [−2, 3] | [2, 9]
Here, P1 = −1, P2 = (−2 + 3) = 1, P3 = (2 + 9) = 11
Special sum = P1 − P2 + P3 = (−1) − 1 + 11 = 9

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Interleaving Subsequences Count

Given three lowercase strings p, q, and r (length ≤ 100), count the number of ways to form
exactly the string r by interleaving a subsequence of p and a subsequence of q, while
preserving the relative order of characters taken from each string. You must use at least
one character from p and at least one character from q. Return the answer modulo 1,000,000,007.

Notes
- “Subsequence” means you may skip characters but cannot reorder them.
- The two chosen subsequences (one from p, one from q) are interleaved to form r.
- At least one character must be taken from each of p and q.

Input Format
- Line 1: string p
- Line 2: string q
- Line 3: string r

Output Format
- A single integer: the number of valid interleavings modulo 1,000,000,007.

Constraints
- 1 ≤ |p|, |q|, |r| ≤ 100
- All strings consist only of lowercase English letters.

Sample
p: ab
q: ba
r: aba

Output:
2

Explanation:
Two valid ways to form "aba":
1) take "a" from p, then "ba" from q
2) take "ab" from p, then "a" from q


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Maximize Subarray-Sum × Pivot Value

Given an array arr of length n, find the maximum possible value of:
    ( sum(arr[i..j]) ) × arr[k]
over all choices of indices i, j, k such that 0 ≤ i ≤ k ≤ j < n.

Input Format
- Line 1: integer n
- Line 2: n space-separated integers arr[0], arr[1], …, arr[n-1]

Output Format
- Print a single integer: the maximum value of (sum of a subarray) multiplied by
  the value at some index k that lies inside that subarray.
  Use 64-bit arithmetic for safety.

Constraints
- 1 ≤ n ≤ 5 × 10^5
- −10^6 ≤ arr[i] ≤ 10^6

Example
Input
5
2 -1 3 -2 4
Output
16

Explanation
Best is to choose subarray [0..4] with sum 6 and k = 4 (arr[k] = 4):
6 × 4 = 24; but even better is subarray [2..4] with sum 5 and k = 4: 5 × 4 = 20.
(Your result should be the maximum over all valid (i, j, k); values can be negative too.)


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem — Minimize Spread After 4-Way Split

You are given an integer N and an array X of N integers (X1 … XN).
Place exactly three cut positions to split X into four **non-empty, contiguous**
subarrays. Let A, B, C, and D be the sums of those four parts (in order).

Your task is to output the **minimum possible value** of:
    max(A, B, C, D) − min(A, B, C, D)

Input Format
• N
• X1 X2 … XN

Output Format
• A single integer: the minimum possible value of max(A,B,C,D) − min(A,B,C,D).

Constraints
• 4 ≤ N ≤ 2⋅10^5
• 0 ≤ Xi ≤ 10^9

Sample 1
Input
5
4 3 5 2 3
Output
2
Explanation
Split as (4) | (3) | (5) | (2,3) → A=4, B=3, C=5, D=5 → 5 − 3 = 2.

Sample 2
Input
7
3 2 1 11 12 5 9
Output
7

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem — Max Equalizable Count with ±1 Operations

You are given an array A of N integers.

For each element Ai you may perform exactly one of the following:
• Add 1 to Ai
• Subtract 1 from Ai
• Do nothing to Ai

After applying these choices to all elements, you may choose any integer K.
Count how many elements are equal to K. Your task is to find the **maximum**
possible count.

Input Format
• The first line contains a single integer N.
• The second line contains N integers: A1 A2 … AN.

Constraints
• 1 ≤ N ≤ 100000
• 0 ≤ Ai ≤ 100000

Output Format
• Print a single integer — the maximum possible number of elements that can be made equal to some K.

Sample
Input
7
3 1 4 1 5 9 2
Output
4
Explanation
Choose K = 2. Values originally equal to 1, 2, or 3 can be turned into 2.
There are 2 (ones) + 1 (two) + 1 (three) = 4 such elements.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Playlist Fun Maximization

You have n songs. The i-th song has:
  - singer[i]: an integer ID of its singer
  - length[i]: its duration (positive integer)

You may reorder the songs arbitrarily. While listening, the fun gained from the
t-th played song equals:
    (# of distinct singers heard among the first t songs) × length of that song.

Goal:
Choose an order that maximizes the total fun
    sum_{t=1..n} (distinct_singers_so_far) * length[ song_at_position_t ],
and return that maximum value.

Constraints
1 ≤ n ≤ 10^5
1 ≤ singer[i] ≤ 10^9
1 ≤ length[i] ≤ 10^9

Example 1
n = 3
singer = [1, 2, 2]
length = [2, 3, 2]
Optimal order: first song (1,2), third song (2,2), second song (2,3)
Fun: 1*2 + 2*2 + 2*3 = 2 + 4 + 6 = 12
Answer: 12

Example 2
n = 3
singer = [1, 1, 2]
length = [5, 4, 3]
Optimal order: second song (1,4), third song (2,3), first song (1,5)
Fun: 1*4 + 2*3 + 2*5 = 4 + 6 + 10 = 20
Answer: 20


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Arranging Numbers (Beautiful Arrangement)

Jayme has the numbers 1..n. A permutation a[1..n] (1-based) is called
“beautiful” if for every position i (1 ≤ i ≤ n) at least one holds:
  - a[i] is divisible by i, OR
  - i is divisible by a[i].
(i.e., a[i] % i == 0 or i % a[i] == 0)

Task:
Count how many beautiful permutations of {1, 2, …, n} exist and return that count.

Input
- A single integer n

Output
- A single integer: the number of beautiful arrangements

Constraints
- 1 < n < 20

Example
Input:
2
Output:
2
Explanation:
Permutations [1,2] and [2,1] both satisfy the divisibility condition at each position.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Element Swapping

Given an array arr of n integers, you may perform the following operation any number of times:
1) Choose an index i (0 ≤ i < n − 1) and swap arr[i] and arr[i + 1].
2) Each element can be swapped at most once during the whole process (i.e., no element participates in more than one swap).

The strength of index i is defined as arr[i] × (i + 1), using 0-based indexing.

Goal:
Find the maximum possible value of
    S = Σ_{i=0}^{n−1} arr[i] × (i + 1)
after applying allowed swaps optimally. Return this maximum.

Example
n = 4
arr = [2, 1, 4, 3]

Optimal swaps:
- swap(arr[2], arr[3])
- swap(arr[0], arr[1])

Final array: [1, 2, 3, 4]
Sum of strengths: 1×1 + 2×2 + 3×3 + 4×4 = 30
Return 30.

Function Description
Complete the function getMaximumSumOfStrengths with the parameter:
    int arr[n]: the initial array
Returns:
    long int: the maximum possible sum of strengths of all indices after optimal swaps.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Maximum Number of Servers Within Budget

Problem Statement
You are given two 0-indexed integer arrays of equal length: bootCost and runCost.
There are n servers in a line. If you run a consecutive group of k servers from
index l to r (k = r - l + 1), the total cost is:

  total_cost(l, r) = max(bootCost[l..r]) + k * sum(runCost[l..r]) + overhead * (k - 1)

where:
- max(bootCost[l..r]) is the largest activation cost in the window [l..r],
- sum(runCost[l..r]) is the sum of running costs in that window,
- overhead is a fixed non-negative integer penalty paid per additional server
  beyond the first in the block (so there are k-1 such links).

You are also given an integer budget.
Return the maximum number k of consecutive servers you can run such that the total
cost does not exceed budget. If no window is affordable, return 0.

Input Format
- Line 1: n
- Line 2: n integers — bootCost[0], bootCost[1], ..., bootCost[n-1]
- Line 3: n integers — runCost[0], runCost[1], ..., runCost[n-1]
- Line 4: two integers — budget and overhead

Output Format
- One integer: the maximum k (length of a contiguous block) that fits within the budget.

Example
Input
5
3 6 1 3 4
2 1 3 4 5
30 1

Output
3


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Challenge: Longest Symmetric Substring with Replacements

Definition
A string is called symmetric if its length is even, the first half consists only of '<'
characters, and the second half consists only of '>' characters.
Examples of symmetric strings: "" (empty string), "<>", "<<>>", "<<<>>>", ...

Task
Given a string S consisting of the characters '<', '>' and/or '?', you may replace each
'?' with either '<' or '>' (independently). Return the length of the longest **contiguous**
substring of S that can be made symmetric after such replacements.

Function signature
int solution(string &S);

Examples
1) S = "<><??>>"
   After replacing all '?' with '<', we get "<<<<<<>". The longest symmetric substring is "<<>>",
   so the function should return 4.

2) S = "??????"
   Replace the first three '?' with '<' and the next three with '>' -> "<<<>>>".
   The function should return 6.

3) S = "<<"
   The function should return 2.

Notes
- |S| is in the range [1 .. 200,000].
- S contains only the characters '<', '>' and '?'.
- Aim for an efficient algorithm.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Lucky Triples

You are given an array a[1..n] of positive integers. Count the number of index triples (i, j, k) such that
  1 ≤ i < j < k ≤ n,
  a[i] divides a[j], and
  a[j] divides a[k].

Print the total number of such triples.

Input
- The first line contains an integer n (1 ≤ n ≤ 2⋅10^5).
- The second line contains n integers a1, a2, …, an (1 ≤ ai ≤ 10^6).

Output
- Print a single integer: the number of triples (i, j, k) with i < j < k, a[i] | a[j], and a[j] | a[k].

Notes
- Use 64-bit integer type for the answer (e.g., long long in C++), as the count can be large.
- Values can repeat; equal values are allowed.

Example 1
Input
4
1 2 2 4

Output
4

Explanation
Valid triples (1-based indices): (1,2,3), (1,2,4), (1,3,4), (2,3,4).

Example 2
Input
6
1 2 3 4 6 12

Output
10

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

C. Maximum Median

You are given an array a of n integers, where n is odd. You can perform the following operation:

- Choose one element of the array (say ai) and increase it by 1 (replace ai with ai + 1).

You want to make the median of the array as large as possible using at most k operations.

Definition:
The median of an odd-sized array is the middle element after the array is sorted in non-decreasing order.
Example: the median of [1, 5, 2, 3, 5] is 3.

Input
The first line contains two integers n and k (1 ≤ n ≤ 2⋅10^5, n is odd, 1 ≤ k ≤ 10^9).
The second line contains n integers a1, a2, …, an (1 ≤ ai ≤ 10^9).

Output
Print a single integer — the maximum possible median after at most k operations.

Examples

Input
3 2
1 3 5
Output
5

Input
5 5
1 2 1 1 1
Output
3

Input
7 7
4 1 2 4 3 4 4
Output
5

Note
- In the first example, you can increase the second element twice to get [1, 5, 5]; median is 5.
- In the second example, increasing the second, third, and fifth elements appropriately yields a median of 3.
- In the third example, increasing the first, fourth, sixth, and seventh elements yields a median of 5.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Time limit: 1.00 s
Memory limit: 512 MB

Problem — Josephus (k-step elimination)

There are n children (numbered 1..n) standing in a circle. Repeatedly, k children are skipped and then the next child is removed from the circle. Determine the order in which the children are removed.

Input
The only input line has two integers n and k.

Output
Print n integers: the removal order.

Constraints
1 ≤ n ≤ 2 · 10^5
0 ≤ k ≤ 10^9

Example
Input:
7 2

Output:
3 6 2 7 5 1 4


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Minimum Total Idle Time (Servers → Tasks)

You have N servers. Each server i takes A[i] time to finish its process.

You must create tasks that use increasing numbers of servers exactly once:
Task 1 uses 1 server
Task 2 uses 2 servers
Task 3 uses 3 servers
…
Task K uses K servers

All servers must be used exactly once. Therefore, N must be a triangular number:
N = 1 + 2 + … + K = K*(K+1)/2
(If no such K exists, output -1.)

For any task (i.e., any chosen group of servers), its idle time is:
idle(group) = max(time in group) − min(time in group)

Goal:
Partition the N servers into K groups of sizes 1,2,…,K so that the sum of idle times
over all groups is minimized. Return that minimum total idle time.

Input:
T                       // number of test cases
For each test case:
  N                     // number of servers
  A1 A2 … AN            // times of the N servers

Output:
For each test case, print a single integer: the minimum possible sum of idle times
(OR -1 if it is impossible to form groups of sizes 1..K that use all servers).

Constraints:
1 ≤ T ≤ 10
1 ≤ N ≤ 1000
1 ≤ A[i] ≤ 10^9
Sum of N over all test cases ≤ 2000

Sample Input:
1
6
1 2 2 2 3 3

Sample Output:
4

Explanation (one optimal partition when N=6 = 1+2+3):
Group sizes: 1 | 2 | 3
Choose (2) | (2,2) | (1,3,3)
Idle times: 0  +  0   +  (3−1)=2  → total 2
Another optimal partition yields total 4 overall minimum across valid partitions is 4.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Compatible Warehouse Pairs in a Weighted Tree

You are given a weighted, undirected tree of N warehouses (nodes), rooted at node 1.
Each edge (u, v) has a positive distance w. For every node v (1-based), you are also given
an integer val[v].

Define distance(u, v) as the sum of edge weights on the unique path between u and v.

A pair (u, v) is called compatible if:
  • u is an ancestor of v in the rooted tree (u lies on the path from 1 to v, u ≠ v), and
  • distance(u, v) ≤ val[v].

Task:
Count the total number of compatible pairs (u, v).

Input Format:
  N
  (N-1) lines follow: u v w      // 1 ≤ u, v ≤ N, edge weight w > 0
  final line: val1 val2 ... valN // values for nodes 1..N

Output Format:
  Print a single integer — the number of compatible pairs.

Notes:
  • The tree is rooted at node 1.
  • Edges are undirected; weights are positive.
  • All node indices are 1-based.

Example
Input:
6
1 6 4
6 5 1
1 2 3
1 4 2
4 3 1
2 1 3 1 5 4

Output:
5

Explanation:
Compatible pairs are:
(1, 6): distance(1,6)=4 ≤ val[6]=4
(1, 5): distance(1,5)=4+1=5 ≤ val[5]=5
(6, 5): distance(6,5)=1 ≤ val[5]=5
(4, 3): distance(4,3)=1 ≤ val[3]=3
(1, 3): distance(1,3)=2+1=3 ≤ val[3]=3
Total = 5.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Title: One-Block Partitions

You are given a binary array Arr of length N (elements are only 0 or 1).

Definition:
A “One block” is a continuous subarray that contains exactly one element equal to 1.

Task:
Partition the entire array Arr into contiguous blocks so that every block is a One block.
Return the total number of different valid partitions. If it is impossible, return 0.

Notes:
- Blocks must cover the whole array without overlap.
- Two partitions are different if they place at least one cut in a different position.

Input
- N : integer, the size of the array (1 ≤ N ≤ 100)
- Arr : N space-separated integers (each 0 or 1)

Output
- A single integer: the number of ways to divide the array into One blocks.

Example 1
Input
3
0 1 0
Output
1
Explanation
The only valid partition is the whole array [0,1,0], which contains exactly one ‘1’.

Example 2
Input
6
1 0 0 1 0 1
Output
6
Explanation
Ones at positions 1,4,6. Zeros between consecutive ones are 2 and 1, so ways = (2+1)*(1+1) = 6.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Title: Unpurchased Categories

There are n items on a website, indexed 0..n-1. The category id of item i is
category[i] (an integer). There are m customers. Customer j buys every item
from index l to r inclusive, given as purchase[j] = [l, r].

Task
Return all DISTINCT category ids for which **no item of that category was ever
purchased by any customer**. Sort the result in ascending order. If every
category had at least one item purchased, return [-1].

Function
vector<int> getUnpurchasedCategories(vector<int> category,
                                     vector<vector<int>> purchase)

Input (custom testing)
n
category[0]
category[1]
...
category[n-1]
m
purchase[0][0] purchase[0][1]
purchase[1][0] purchase[1][1]
...
purchase[m-1][0] purchase[m-1][1]

Output
A line with the desired category ids in ascending order (or -1 if none).

Constraints
1 ≤ n ≤ 1e5
1 ≤ category[i] ≤ 1e9
0 ≤ m ≤ 1e5
0 ≤ purchase[j][0] ≤ purchase[j][1] < n

Example
n = 5
category = [1, 2, 5, 4, 5]
m = 3
purchase = [[0, 1], [0, 2], [1, 2]]

Items purchased cover indices {0,1,2}; thus categories purchased are {1,2,5}.
Category 4 never appears among purchased indices → answer: [4].

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Title: Assign Requests to Least-Loaded Servers

You have N servers labeled 1..N. Initially, each server’s total load is 0.
There are M incoming requests; the i-th request has load requests[i].

Assignment rule for each request (in order):
1) Choose the server with the smallest current total load.
2) If multiple servers tie, choose the one with the smallest label.
3) Assign the request to that server and increase that server’s load by the request’s load.

Task
Return an array of length M where the i-th element is the label of the server that handles the i-th request.

Input (for custom testing)
N
M
requests[0] requests[1] ... requests[M-1]

Output
M lines, each with the label (1..N) of the server that handled the corresponding request.

Constraints
1 ≤ N ≤ 2 * 10^5
1 ≤ M ≤ 2 * 10^5
0 ≤ requests[i] ≤ 10^9

Notes / Hint
Use a min-heap (priority queue) of (current_load, label) to always pop the least-loaded server; this
automatically breaks ties by smallest label.

Example
Input
2
2
5 5
Output
1
2
Explanation:
Start loads: (0,#1), (0,#2). First request -> #1 (tie broken by smallest label).
Loads become (5,#1), (0,#2). Second request -> #2. Final assignment sequence: [1, 2].


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem Statement:
You are given an integer array arr of length n.
You can perform the following operation exactly k times:

1. Choose any index i (0 ≤ i < n) and add arr[i] to your total score.
2. After choosing i, discard either all elements to the left of i (arr[0..i−1])
   or all elements to the right of i (arr[i+1..n−1]).
   The remaining part becomes the new array for the next operation.

Your task is to maximize the total score after exactly k operations.

Example:
Input:
n = 6
arr = [4, 6, -10, -1, 10, -20]
k = 4

Process:
1. Choose arr[4] = 10 → keep left → arr = [4, 6, -10, -1], score = 10
2. Choose arr[0] = 4 → keep right → arr = [6, -10, -1], score = 14
3. Choose arr[0] = 6 → keep right → arr = [-10, -1], score = 20
4. Choose arr[1] = -1 → keep right → arr = [ ], score = 19

Output:
19

Explanation:
Each time you pick an element, you can only continue from one side.
However, any subset of k elements can be picked if you always choose
from the extremes of your target indices.
Therefore, the maximum total score equals the sum of the k largest
elements in the array.

Constraints:
1 ≤ n ≤ 10⁵
−10⁹ ≤ arr[i] ≤ 10⁹
1 ≤ k ≤ n


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem — Count Beautiful Subarrays

You are given an array A of length n (0-indexed). A subarray is called “beautiful” if:
• Its length is odd (always beautiful), OR
• Its length is even and the two middle elements are equal.

Formally, for a subarray A[l..r] with length L = r − l + 1:
• If L is odd → beautiful.
• If L is even → beautiful iff A[l + L/2 − 1] == A[l + L/2].

Your task is to count the total number of beautiful subarrays of A.

Input
• n — the length of the array (1 ≤ n ≤ 2⋅10^5)
• A1, A2, …, An — the array elements (1 ≤ Ai ≤ 10)

Output
• A single integer: the number of beautiful subarrays.

Example
Input:
5
3 1 2 2 4

Output:
11

Explanation (informal):
All odd-length subarrays are beautiful. Among even-length subarrays, only those whose two middle elements are equal are counted (e.g., [1,2,2,4] has middle elements 2 and 2).



XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Minimum Shifts

Given an n×m binary matrix mat (provided as an array of strings of length m),
you may perform row operations. In one operation you can cyclically shift a single
row by 1 position either to the left or to the right (wrapping around). Each 1-step
shift counts as cost 1.

Task:
Find the minimum total number of shifts needed so that there exists at least one
column whose cells are all '1'. If it is impossible, return -1.

Notes:
• mat[i] is the i-th row; all rows have equal length m.
• A cyclic left shift moves each character one position left and the first character
  goes to the end. A cyclic right shift moves each character one position right and
  the last character goes to the front.

Function to implement:
int findMinimumShifts(vector<string> mat);

Return:
An integer — the minimum number of shifts required to make at least one column
all '1', or -1 if not possible.

Constraints:
1 ≤ n ≤ 10000
1 ≤ m ≤ 1000
Each mat[i] consists only of characters '0' and '1'.

Input format (for custom testing):
Line 1: n
Next n lines: each line is a binary string of length m describing a row of the matrix.

Output (for custom testing):
Single integer — the answer.

Example 1:
Input
4
0101
1010
0100
0001
Output
3
Explanation
Rotate row 1 right (0101→1010), row 3 right (0100→0010), row 4 left (0001→0010).
Then column 3 becomes all '1'. Total shifts = 3.

Example 2:
Input
3
111
101
000
Output
-1
Explanation
The third row is all zeros, so no column can be made all '1'.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Question: finalPrice — Shopkeeper Sale

A shopkeeper arranges items in a list for a sale. From left to right, each
item i is sold at its full price price[i] minus the price of the first item
to its right with a price that is less than or equal to price[i]. If no such
item exists, item i is sold at full price.

Given an integer array prices, compute:
  1) The total cost (sum of all final prices).
  2) The 0-based indices of the items that are sold at full price
     (i.e., no discount applied), in ascending index order.

Print the results as:
  <total_cost>
  <index1 index2 ...>

Constraints
- 1 ≤ n ≤ 100000
- 1 ≤ prices[i] ≤ 1000000

Example
prices = [2, 3, 1, 2, 4, 2]
Final prices = [1, 2, 1, 0, 2, 2]
Total cost = 8
Full-price indices = 2 5
Output:
8
2 5

Sample 0
n = 6
prices = [5, 1, 3, 4, 6, 2]
Output:
14
1 5

Sample 1
n = 5
prices = [1, 3, 3, 2, 5]
Output:
9
0 3 4


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Question: countBalancedNumbers — Balanced Numbers in a Permutation

You are given a permutation p of length n (i.e., it contains each integer
from 1 to n exactly once in any order).

A number k (1 ≤ k ≤ n) is called balanced if there exist indices l and r
(1 ≤ l ≤ r ≤ n) such that the subarray p[l], p[l+1], …, p[r] is a permutation
of the numbers {1, 2, …, k}. In other words, within some contiguous segment
of p you can find all numbers 1..k exactly once.

For each k from 1 to n, determine whether k is balanced. Return a binary
string of length n where the i-th character is ‘1’ if i is balanced and ‘0’
otherwise.

Input
- First line: integer n
- Second line: n integers — the permutation p1 … pn

Output
- A single line containing the binary string described above.

Constraints
- 1 ≤ n ≤ 2 × 10^5
- 1 ≤ p[i] ≤ n
- All p[i] are distinct.

Example
n = 4
p = [4, 1, 3, 2]
Balanced numbers are 1, 3, and 4 (but not 2), so the output is:
1011

Sample 0
Input:
5
5 3 1 2 4
Output:
11111

Sample 1
Input:
4
1 4 2 3
Output:
1001


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem Summary
You have N robots in a line, each with:

Health (positive integer)
Direction (0 = left, 1 = right)

Rules

Robots move simultaneously in their directions
When two robots collide (moving towards each other):

The robot with less health is knocked out
The robot with more health continues with health reduced by opponent's health
If same health, both are knocked out


Robots never change direction

Input

N: number of robots
A: 2D array of size N×2

A[i][0] = health of robot i
A[i][1] = direction of robot i (0=left, 1=right)



Output
Return a 2D array with [health, direction] of surviving robots in their original order (1 to N).
Example
Input:

N = 4
A = [[39, 1], [20, 0], [21, 0], [12, 0]]

Output:

[[2, 0], [12, 0]]

Explanation:

Robot 1 (health 39, right) collides with Robot 2 (health 20, left) → Robot 1 survives with 19 health
Robot 1 (health 19, right) collides with Robot 3 (health 21, left) → Robot 3 survives with 2 health
Robot 3 (health 2, left) and Robot 4 (health 12, left) both move left, never collide
Final survivors: Robot 3 [2, 0] and Robot 4 [12, 0]


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Amazon has N packages lined up for delivery.
The weight of the i-th package is given by arr[i].

A delivery team wants to analyze performance by checking
continuous groups of packages where the average package
weight is greater than or equal to K.

Your task is to find the number of such continuous subarrays
that satisfy this condition.

Example:
N = 5, K = 4
arr = [3, 4, 5, 6, 2]

Output: 12

The continuous groups of packages with average weight >= 4
are: [3,4,5], [4,5], [4,5,6], [5,6], [6], [3,4,5,6], [4,5,6,2], [3,4,5,6,2].

Constraints:
1 ≤ N ≤ 100000
1 ≤ arr[i], K ≤ 10^9

Input Format:
The first line contains two integers N and K — the number of
packages and the threshold average weight.

The second line contains N integers representing the weights
of the packages.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Quiz Competition

A class has students with various talents, each represented by an integer from 1 to talentsCount. 
You need to form teams for a quiz competition, where each team must have at least one member with 
each talent.

Teams must be formed from consecutive students in the array. For each possible starting position, 
determine the minimum number of students needed to form a valid team. If it is not possible to form 
a team with all talents from a particular starting position, return -1 for that position.

Example:
talentsCount = 3
talent = [1, 2, 3, 2, 1]

- Starting at position 1: [1, 2, 3] includes all talents, minimum size = 3
- Starting at position 2: [2, 3, 2, 1] is the smallest subarray with all talents, minimum size = 4
- Starting at position 3: [3, 2, 1] includes all talents, minimum size = 3
- Starting at positions 4 and 5: Cannot form a team with all talents, return -1

The result is [3, 4, 3, -1, -1].

Function Description:
Complete the function teamSize in the editor with the following parameter(s):
- int talent[n]: the students' talents
- int talentsCount: the number of talents represented numbered from 1 to talentsCount

Returns:
- int[n]: at each index, the minimum size subarray required, or -1 if an appropriate subarray does not exist

Constraints:
- 1 ≤ n, talentsCount ≤ 10^5
- 1 ≤ talent[i] ≤ talentsCount

Sample Input:
n = 8
talent = [1, 1, 2, 2, 3, 1, 3, 2]
talentsCount = 3

Sample Output:
5
4
4
3
4
3
-1
-1

Explanation:
The shortest subarrays for each position:
Beginning at the first position: [1, 1, 2, 2, 3] (length 5)
Second position: [1, 2, 2, 3] (length 4)
Third position: [2, 2, 3, 1] (length 4)
Fourth position: [2, 3, 1] (length 3)
Fifth position: [3, 1, 3, 2] (length 4)
Sixth position: [1, 3, 2] (length 3)

No further subarrays will have 3 elements.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Connect the Country 2

There are n cities in a country, each with an associated cost given in an array called cost. 
The cost to build a bidirectional road between two cities i and j is the sum of their respective 
costs, cost[i] + cost[j]. Additionally, there are m offers available, each defined by a triplet 
[i, j, k], meaning a road can be built between cities i and j for a cost of k.

You can choose to either use an offer or pay the sum of the costs to build a road between two cities. 
The goal is to determine the minimum cost required to ensure all cities are interconnected, meaning 
there is a path between every pair of cities.

Example:
n = 5
m = 2
cost = [3, 1, 2, 3, 1]
offers = [[3, 4, 1], [1, 5, 6]]

Optimally, you can build the roads as follows:
- Build a road between cities 3 and 2, and pay the cost of cost[3] + cost[2] = 2+1 = 3 units.
- Build a road between cities 3 and 4, and use the first offer to pay the cost of 1 unit.
- Build a road between cities 5 and 1, and pay the cost of cost[5] + cost[1] = 1+3 = 4 units.
- Build a road between the cities 2 and 5, and pay the cost of cost[2] + cost[5] = 1+1 = 2 units.

So, the total cost = 3 + 1 + 4 + 2 = 10.

Function Description:
Complete the function minimumCost in the editor with the following parameters:
- int costs[n]: the cost associated with each city
- int offers[m][3]: the offers available

Returns:
- int: the minimum cost required to connect all the cities

Constraints:
- 2 ≤ n ≤ 10^5
- 1 ≤ m ≤ 10^5
- 1 ≤ cost[i] ≤ 10^4
- 1 ≤ offer[i][0], offer[i][1] ≤ n, offer[i][0] ≠ offer[i][1]
- 1 ≤ offer[i][2] ≤ 10^4

Sample Input:
n = 3
cost = [1, 2, 1]
m = 3
offers = [[1, 3, 4], [1, 2, 4], [3, 2, 1]]

Sample Output:
3

Explanation:
Optimally, build the roads as follows:
- Build a road between cities 3 and 1, and pay the cost of cost[3] + cost[1] = 1+1 = 2 units.
- Build a road between cities 3 and 2, and use the third offer to pay the cost of 1 unit.

So, the total cost = 2 + 1 = 3.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Code Question 1 - Amazon Subscription Model

Amazon is designing a new subscription model for its cloud services. 
The company offers n types of base plans, with their respective costs 
stored in an array planCost, and m types of additional features, each 
with its own cost stored in an array featureCost.

Customers can select one base plan and one additional feature. The 
total subscription cost is the sum of the base plan's cost and the 
feature's cost.

However, there are X specific combinations of base plans and features 
that are not allowed due to technical restrictions. These incompatible 
combinations are represented by two arrays, incompatiblePlans and 
incompatibleFeatures, where incompatiblePlans[i] and incompatibleFeatures[i] 
represent the base plan and the additional feature that cannot be paired 
together (in 1-based indexing).

Out of all possible valid combinations of a base plan and an additional 
feature, the task is to find the maximum cost of any valid combination.

Note: The constraints guarantee that there will always be at least one 
valid combination available.

Example:
n = 2
m = 2
X = 1
planCost = [5, 10]
featureCost = [2, 6]
incompatiblePlans = [1]
incompatibleFeatures = [2]

Exploring all the possible valid combinations of a base plan and an 
additional feature (1-based indexing):

| Base Plan | Additional | Is          | Total         |
| Index-(i) | Feature    | Combination | Subscription  |
|           | Index-(j)  | Valid?      | Cost          |
|-----------|------------|-------------|---------------|
| 1         | 1          | Yes         | 5 + 2 = 7     |
| 1         | 2          | No          | -             |
| 2         | 1          | Yes         | 10 + 2 = 12   |
| 2         | 2          | Yes         | 10 + 6 = 16   |

Out of all the possible valid combinations, the maximum subscription 
cost possible is 16.

Another Example:
n = 3
m = 2
X = 2
planCost = [2, 1, 5]
featureCost = [1, 6]
incompatiblePlans = [1, 2]
incompatibleFeatures = [1, 2]

Sample Output: 7

Explanation:
Exploring all the possible valid combinations of a base plan and an 
additional feature (1-based indexing):

| Base Plan | Additional | Is          | Total         |
| Index-(i) | Feature    | Combination | Subscription  |
|           | Index-(j)  | Valid?      | Cost          |
|-----------|------------|-------------|---------------|
| 1         | 1          | No          | -             |
| 1         | 2          | Yes         | 2 + 6 = 8     |
| 2         | 1          | Yes         | 1 + 1 = 2     |
| 2         | 2          | No          | -             |
| 3         | 1          | Yes         | 5 + 1 = 6     |
| 3         | 2          | No          | -             |

Out of all the possible valid combinations, the maximum subscription 
cost possible is 7.
Hence, the answer is 7.

Function Description:
Complete the function getMaximumCost in the editor below.

Function Parameters:
- int planCost[n]: the base prices of the subscription plans
- int featureCost[m]: the costs of the additional features
- int incompatiblePlans[X]: the indices of the incompatible 
  subscription plans
- int incompatibleFeatures[X]: the indices of the incompatible 
  features

Returns:
- int: the maximum cost of a valid combination

Constraints:
- 2 ≤ n, m ≤ 10^5
- 1 ≤ X ≤ min(2 * 10^5, (n * m) - 1)
- 1 ≤ planCost[i], featureCost[i] ≤ 10^9
- 1 ≤ incompatiblePlans[i] ≤ n
- 1 ≤ incompatibleFeatures[i] ≤ m
- The pair (incompatiblePlans[i], incompatibleFeatures[i]) is unique 
  for every i.
- At least one valid combination always exists.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Code Question 2 - Amazon Data Distribution Algorithm

The developers at Amazon are working on an algorithm for their data 
distribution over regions based on a parameter called affinity defined 
for each data place. There are n (n is even) different data places 
where the affinity parameter of the ith place is represented by 
affinity[i]. The data needs to be distributed over 2 regions, namely 
regionA and regionB. In each step of the algorithm, a region is 
chosen and then a data place is migrated to that region. The same 
region cannot be chosen in consecutive steps. Each time a region is 
selected, it is configured to maximize the total affinity of data it will 
store and decides which data place to choose accordingly.

Moreover, there are certain pre-defined rules for the data distribution 
represented by m unique pairs of indices, the indexes follow 1-based 
indexing in the input, in a matrix rules. For each unique pair (x, y), if 
the data piece present at the indices x or y is selected for a region, 
the other must be selected for the next region in the next step 
mandatorily.

Find the maximum possible sum of memory stored in regionA.

Example:
Given n = 6, affinity = [3, 2, -4, 8, 3, -7], m = 2, rules = [[2, 4], [3, 6]]

| Region | Affinity | Reason |
|--------|----------|--------|
| A      | -4       | Forces regionB to choose -7 because of rule (3, 6) |
| B      | -7       | Forced by rule (3, 6) |
| A      | 8        | Forces regionB to choose 2 because of rule (2, 4) |
| B      | 2        | Forced by rule (2, 4) |
| A      | 3        | Maximum affinity out of the remaining |
| B      | 3        | Last available data piece |

The total affinity of regionA = (-4) + 8 + 3 = 7, which is the maximum 
possible sum of memory stored in regionA.

Sample Case 0:
n = 4
affinity = [1, 2, 3, 4]
m = 1
rules = [[4, 2]]

Sample Output: 7

Explanation:
For the regionA, the indices of the data places are chosen in the 
order [4, 3]. This will force the regionB to choose the data places at 
the indices in the order [2, 1].
The maximum possible affinity for regionA is 4 + 3 = 7.

Sample Case 1:
n = 6
affinity = [1, 2, 3, 4, 5, 6]
m = 3
rules = [[4, 2], [3, 4], [5, 6]]

Sample Output: 12

Explanation:
For the regionA, the indices of the data places are chosen in the 
order [6, 4, 2]. This will force the regionB to choose the data places at 
the indices in the order [5, 3, 1].
The maximum possible affinity for regionA is 6 + 4 + 2 = 12.

Function Description:
Complete the function maximumAffinity in the editor below.
maximumAffinity has the following parameters:
- int affinity[n]: the affinity parameter for different data places
- int rules[m][2]: the different pair of indices, rules[i][0] and rules[i][1] 
  denote the i-th unique pair.

Returns:
- long int: the maximum possible affinity for regionA.

Constraints:
- 2 ≤ n ≤ 10^5, n is even.
- -10^9 ≤ affinity[i] ≤ 10^9
- 1 ≤ m ≤ n/2
- 1 ≤ rules[i][j] ≤ N
- All the values in rules are distinct.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

🚖 Uber SDE-1 Interview Question: Median in Prefix Subarrays
Problem Context
Uber’s data analytics team is studying the dynamic stability of their driver ratings system.
 Each driver receives a unique rating (a permutation of integers from 1 to n), representing the relative performance among n drivers.
The team wants to analyze how the set of possible median ratings evolves as new drivers join one by one.

Task
You are given a permutation p of size n, where p[i] represents the rating of the i-th driver joining the system.
For each prefix of this permutation (i.e., first i drivers), determine f(i) — the count of distinct ratings among the first i drivers that can act as a median of at least one subarray completely contained within that prefix.
Formally, for each i (1 ≤ i ≤ n):
f(i) = number of distinct elements x in p[1...i] such that x is the median of some subarray of p[1...i] and size of subarray>=2 
You must output all f(1), f(2), ..., f(n).
Median Definition
For a subarray of size m:
If m is odd, the median is the element at position (m + 1) / 2 after sorting.
If m is even, the median is the element at position m / 2 after sorting (i.e., the lower median)
Example
Input:
5
3 1 4 5 2

Output:

0 1 2 3 

Constraints
1 ≤ n ≤ 2 × 10^5

1 ≤ p[i] ≤ n

p is a permutation of integers 1...n

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem: Minimum Operations to Sort by Zeroing Values

You are given an array a of length n.
You may perform the following operation any number of times:

Operation:
- Choose any integer x.
- For all indices i with a[i] = x, set a[i] = 0 (all such positions change in one operation).

Goal:
Find the minimum number of operations needed to make the array sorted in non-decreasing order.

Input Format
- The first line contains an integer n — the length of the array.
- The second line contains n integers a1, a2, ..., an — the array elements.

Output Format
- Print a single integer — the minimum number of operations required to make the array non-decreasing.

Constraints
- 1 < n ≤ 10^3
- 1 ≤ ai ≤ n

Sample Input
3
3 3 2

Sample Output
1

Explanation
Choose x = 3. After the operation, the array becomes [0, 0, 2], which is already non-decreasing. Hence, only 1 operation is needed.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem: Time to Remove All "01" Substrings

You are given a binary string s consisting of characters '0' (red) and '1' (blue).
A process runs in discrete seconds. At each second, ALL substrings equal to "01"
that are present in s are simultaneously replaced with "10".
Repeat this each second until there is no "01" left in s.

Task
Return the total number of seconds required for the process to stop.

Input
- A single line containing the binary string s (1 ≤ |s| ≤ 2e5).

Output
- A single integer: the number of seconds until no "01" remains.

Example 1
Input
0101
Output
2
Explanation
t=0: 0101  (two "01" at positions 0 and 2)
t=1: 1010
t=2: 1100  (no "01" → stop)

Example 2
Input
1111
Output
0
Explanation
No "01" exists initially.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

 Question 

For each word in a list, determine the minimum number of character replacements needed so that no two adjacent characters are the same.
If any two adjacent characters in a string are equal, one of them must be changed. Calculate the minimum number of substitutions required for each word.

Example
words = ["add", "boook", "break"]

"add": change one 'd' (1 change)
"boook": change the middle 'o' (1 change)
"break": no changes necessary (0 changes)

The return array is [1, 1, 0].

Function Description
Complete the function minimalOperations in the editor with the following parameter:

string words[n]: an array of strings

Returns
int[n]: each element i is the minimum number of substitutions for words[i].

Constraints
1 ≤ n ≤ 100
2 ≤ length of words[i] ≤ 10^5
Each character of words[i] is in the range ascii[a-z].

--------------------------------
Sample Case 0
--------------------------------

Sample Input 0
5
ab
aab
abb
abab
abaaaba

Sample Output 0
0
1
1
0
1

Explanation 0
words[0] = "ab" is already acceptable, so 0 replacements are needed.
words[1] = "aab" is not acceptable. Replace an 'a' with an appropriate character, so 1 replacement.
words[2] = "abb" is not acceptable. Replace a 'b' with an appropriate character, again 1 replacement.
words[3] = "abab" is already acceptable, so 0 replacements are needed.
words[4] = "abaaaba" is not acceptable. Replace the middle 'a' in "aaa", 1 replacement.

The return array is [0, 1, 1, 0, 1].


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

In one operation on an array of integers:

• Choose any two adjacent elements.
• Insert the sum of the adjacent pair in their place.

Given an array of integers arr[n], perform this operation 0 or more times to create a non-decreasing array. Choose the operations to maximize the length of the resultant sorted array. Return that maximum length.

Example
n = 5
arr = [2, 4, 1, 6, 12]

Using 0-based indexing, choose arr[2] = 1 and arr[3] = 6. Replace the pair with their sum, 1 + 6 = 7, to yield [2, 4, 7, 12]. The array is non-decreasing and contains 4 elements. This is the longest result possible, so return 4.

Function Description
Complete the function optimalSumOperations in the editor below.

optimalSumOperations has the following parameter:
• int arr[n]: the array to sort

Returns
• int: the maximum length array one can obtain

Constraints
• 1 ≤ n ≤ 2 × 10^3
• 1 ≤ arr[i] ≤ 10^9


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Stone Game – stoneDifference

You are given an integer n and an array stones of length n, where stones[i] is the value of the i-th stone.

Two players A and B play a game. A moves first, then they alternate turns.

On each turn, the current player must choose exactly ONE stone to remove from the array, but only from one of the two ends:
- Either remove the leftmost stone, or
- Remove the rightmost stone.

Let S be the sum of the values of all stones that remain AFTER the chosen stone is removed.
The current player’s score for that move increases by S.

The game continues until there are no stones left.

Both players play optimally, each trying to maximize their own final total score.

Your task:
Return the final score difference between A and B, defined as:
    (total score of A) – (total score of B),
assuming both play optimally.

Examples:

Example 1:
Input:
n = 5
stones = [5, 3, 1, 4, 2]

Output:
6

Example 2:
Input:
n = 8
stones = [7, 90, 5, 1, 100, 10, 10, 2]

Output:
122


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

The Dungeon Escape Challenge – findSafeWalk

You are given:
- An m x n binary matrix grid.
- An integer health representing your starting health.

Grid rules:
- grid[i][j] = 0 → safe cell, your health does not change when you step here.
- grid[i][j] = 1 → trap cell, you lose 1 health when you step here.

You start at the top-left cell (0, 0) with initial health.
You want to reach the bottom-right cell (m - 1, n - 1).

Movement rules:
- From a cell (i, j), you may move to one of its 4-directionally adjacent neighbors:
  - Up:    (i - 1, j)
  - Down:  (i + 1, j)
  - Left:  (i, j - 1)
  - Right: (i, j + 1)
- You may not move outside the grid.
- When you step onto a trap cell (value 1), your health decreases by 1.
- Your health must always remain strictly greater than 0.
  - If at any point your health becomes 0 or negative, you die and that path is invalid.

Task:
Among all valid paths from (0, 0) to (m - 1, n - 1) that never let your health be ≤ 0:
- Compute the maximum possible remaining health when you arrive at (m - 1, n - 1).

Return:
- The maximum remaining health at (m - 1, n - 1), if there exists at least one valid path.
- If there is no valid path that keeps you alive, return -1.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
